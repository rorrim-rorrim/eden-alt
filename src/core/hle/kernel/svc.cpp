// SPDX-FileCopyrightText: Copyright 2025 Eden Emulator Project
// SPDX-License-Identifier: GPL-3.0-or-later
// SPDX-FileCopyrightText: Copyright 2023 yuzu Emulator Project
// SPDX-License-Identifier: GPL-2.0-or-late

// This file is automatically generated using svc_generator.py.
// DO NOT MODIFY IT MANUALLY

#include <type_traits>

#include "core/arm/arm_interface.h"
#include "core/core.h"
#include "core/hle/kernel/k_process.h"
#include "core/hle/kernel/svc.h"

namespace Kernel::Svc {

static uint32_t GetArg32(std::span<uint64_t, 8> args, int n) {
    return uint32_t(args[n]);
}

static void SetArg32(std::span<uint64_t, 8> args, int n, uint32_t result) {
    args[n] = result;
}

static uint64_t GetArg64(std::span<uint64_t, 8> args, int n) {
    return args[n];
}

static void SetArg64(std::span<uint64_t, 8> args, int n, uint64_t result) {
    args[n] = result;
}

// Like bit_cast, but handles the case when the source and dest
// are differently-sized.
template <typename To, typename From>
    requires(std::is_trivial_v<To> && std::is_trivially_copyable_v<From>)
static To Convert(const From& from) {
    To to{};
    if constexpr (sizeof(To) >= sizeof(From))
        std::memcpy(std::addressof(to), std::addressof(from), sizeof(From));
    else
        std::memcpy(std::addressof(to), std::addressof(from), sizeof(To));
    return to;
}
static_assert(sizeof(ArbitrationType) == 4);
static_assert(sizeof(BreakReason) == 4);
static_assert(sizeof(CodeMemoryOperation) == 4);
static_assert(sizeof(DebugThreadParam) == 4);
static_assert(sizeof(DeviceName) == 4);
static_assert(sizeof(HardwareBreakPointRegisterName) == 4);
static_assert(sizeof(Handle) == 4);
static_assert(sizeof(InfoType) == 4);
static_assert(sizeof(InterruptType) == 4);
static_assert(sizeof(IoPoolType) == 4);
static_assert(sizeof(KernelDebugType) == 4);
static_assert(sizeof(KernelTraceState) == 4);
static_assert(sizeof(LimitableResource) == 4);
static_assert(sizeof(MemoryMapping) == 4);
static_assert(sizeof(MemoryPermission) == 4);
static_assert(sizeof(PageInfo) == 4);
static_assert(sizeof(ProcessActivity) == 4);
static_assert(sizeof(ProcessInfoType) == 4);
static_assert(sizeof(Result) == 4);
static_assert(sizeof(SignalType) == 4);
static_assert(sizeof(SystemInfoType) == 4);
static_assert(sizeof(ThreadActivity) == 4);
static_assert(sizeof(ilp32::LastThreadContext) == 16);
static_assert(sizeof(ilp32::PhysicalMemoryInfo) == 16);
static_assert(sizeof(ilp32::SecureMonitorArguments) == 32);
static_assert(sizeof(lp64::LastThreadContext) == 32);
static_assert(sizeof(lp64::PhysicalMemoryInfo) == 24);
static_assert(sizeof(lp64::SecureMonitorArguments) == 64);
static_assert(sizeof(bool) == 1);
static_assert(sizeof(int32_t) == 4);
static_assert(sizeof(int64_t) == 8);
static_assert(sizeof(uint32_t) == 4);
static_assert(sizeof(uint64_t) == 8);

static void SvcWrap_SetHeapSize64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    uint64_t out_address{};
    Result ret = SetHeapSize64From32(system, std::addressof(out_address), size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_address));
}

static void SvcWrap_SetMemoryPermission64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg32(args, 2));
    Result ret = SetMemoryPermission64From32(system, address, size, perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SetMemoryAttribute64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t mask = Convert<uint32_t>(GetArg32(args, 2));
    uint32_t attr = Convert<uint32_t>(GetArg32(args, 3));
    Result ret = SetMemoryAttribute64From32(system, address, size, mask, attr);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t dst_address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t src_address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Result ret = MapMemory64From32(system, dst_address, src_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t dst_address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t src_address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Result ret = UnmapMemory64From32(system, dst_address, src_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_QueryMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_memory_info = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 2));
    PageInfo out_page_info{};
    Result ret = QueryMemory64From32(system, out_memory_info, std::addressof(out_page_info), address);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_page_info));
}

static void SvcWrap_ExitProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    ExitProcess64From32(system);
}

static void SvcWrap_CreateThread64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t func = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t arg = Convert<uint32_t>(GetArg32(args, 2));
    uint32_t stack_bottom = Convert<uint32_t>(GetArg32(args, 3));
    int32_t priority = Convert<int32_t>(GetArg32(args, 0));
    int32_t core_id = Convert<int32_t>(GetArg32(args, 4));
    Handle out_handle{};
    Result ret = CreateThread64From32(system, std::addressof(out_handle), func, arg, stack_bottom, priority, core_id);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_StartThread64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = StartThread64From32(system, thread_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ExitThread64From32(Core::System& system, std::span<uint64_t, 8> args) {
    ExitThread64From32(system);
}

static void SvcWrap_SleepThread64From32(Core::System& system, std::span<uint64_t, 8> args) {
    std::array<uint32_t, 2> ns_gather{};
    ns_gather[0] = GetArg32(args, 0);
    ns_gather[1] = GetArg32(args, 1);
    int64_t ns = Convert<int64_t>(ns_gather);
    SleepThread64From32(system, ns);
}

static void SvcWrap_GetThreadPriority64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 1));
    int32_t out_priority{};
    Result ret = GetThreadPriority64From32(system, std::addressof(out_priority), thread_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_priority));
}

static void SvcWrap_SetThreadPriority64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 0));
    int32_t priority = Convert<int32_t>(GetArg32(args, 1));
    Result ret = SetThreadPriority64From32(system, thread_handle, priority);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetThreadCoreMask64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 2));
    int32_t out_core_id{};
    uint64_t out_affinity_mask{};
    Result ret = GetThreadCoreMask64From32(system, std::addressof(out_core_id), std::addressof(out_affinity_mask), thread_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_core_id));
    auto out_affinity_mask_scatter = Convert<std::array<uint32_t, 2>>(out_affinity_mask);
    SetArg32(args, 2, out_affinity_mask_scatter[0]);
    SetArg32(args, 3, out_affinity_mask_scatter[1]);
}

static void SvcWrap_SetThreadCoreMask64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 0));
    int32_t core_id = Convert<int32_t>(GetArg32(args, 1));
    std::array<uint32_t, 2> affinity_mask_gather{};
    affinity_mask_gather[0] = GetArg32(args, 2);
    affinity_mask_gather[1] = GetArg32(args, 3);
    uint64_t affinity_mask = Convert<uint64_t>(affinity_mask_gather);
    Result ret = SetThreadCoreMask64From32(system, thread_handle, core_id, affinity_mask);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetCurrentProcessorNumber64From32(Core::System& system, std::span<uint64_t, 8> args) {
    int32_t ret = GetCurrentProcessorNumber64From32(system);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SignalEvent64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle event_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = SignalEvent64From32(system, event_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ClearEvent64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle event_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = ClearEvent64From32(system, event_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapSharedMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle shmem_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    MemoryPermission map_perm = Convert<MemoryPermission>(GetArg32(args, 3));
    Result ret = MapSharedMemory64From32(system, shmem_handle, address, size, map_perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapSharedMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle shmem_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Result ret = UnmapSharedMemory64From32(system, shmem_handle, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_CreateTransferMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    MemoryPermission map_perm = Convert<MemoryPermission>(GetArg32(args, 3));
    Handle out_handle{};
    Result ret = CreateTransferMemory64From32(system, std::addressof(out_handle), address, size, map_perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_CloseHandle64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = CloseHandle64From32(system, handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ResetSignal64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = ResetSignal64From32(system, handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_WaitSynchronization64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t handles = Convert<uint32_t>(GetArg32(args, 1));
    int32_t num_handles = Convert<int32_t>(GetArg32(args, 2));
    std::array<uint32_t, 2> timeout_ns_gather{};
    timeout_ns_gather[0] = GetArg32(args, 0);
    timeout_ns_gather[1] = GetArg32(args, 3);
    int64_t timeout_ns = Convert<int64_t>(timeout_ns_gather);
    int32_t out_index{};
    Result ret = WaitSynchronization64From32(system, std::addressof(out_index), handles, num_handles, timeout_ns);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_index));
}

static void SvcWrap_CancelSynchronization64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = CancelSynchronization64From32(system, handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ArbitrateLock64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t tag = Convert<uint32_t>(GetArg32(args, 2));
    Result ret = ArbitrateLock64From32(system, thread_handle, address, tag);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ArbitrateUnlock64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    Result ret = ArbitrateUnlock64From32(system, address);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_WaitProcessWideKeyAtomic64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t cv_key = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t tag = Convert<uint32_t>(GetArg32(args, 2));
    std::array<uint32_t, 2> timeout_ns_gather{};
    timeout_ns_gather[0] = GetArg32(args, 3);
    timeout_ns_gather[1] = GetArg32(args, 4);
    int64_t timeout_ns = Convert<int64_t>(timeout_ns_gather);
    Result ret = WaitProcessWideKeyAtomic64From32(system, address, cv_key, tag, timeout_ns);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SignalProcessWideKey64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t cv_key = Convert<uint32_t>(GetArg32(args, 0));
    int32_t count = Convert<int32_t>(GetArg32(args, 1));
    SignalProcessWideKey64From32(system, cv_key, count);
}

static void SvcWrap_GetSystemTick64From32(Core::System& system, std::span<uint64_t, 8> args) {
    int64_t ret = GetSystemTick64From32(system);
    auto ret_scatter = Convert<std::array<uint32_t, 2>>(ret);
    SetArg32(args, 0, ret_scatter[0]);
    SetArg32(args, 1, ret_scatter[1]);
}

static void SvcWrap_ConnectToNamedPort64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t name = Convert<uint32_t>(GetArg32(args, 1));
    Handle out_handle{};
    Result ret = ConnectToNamedPort64From32(system, std::addressof(out_handle), name);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_SendSyncRequest64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle session_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = SendSyncRequest64From32(system, session_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SendSyncRequestWithUserBuffer64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t message_buffer = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t message_buffer_size = Convert<uint32_t>(GetArg32(args, 1));
    Handle session_handle = Convert<Handle>(GetArg32(args, 2));
    Result ret = SendSyncRequestWithUserBuffer64From32(system, message_buffer, message_buffer_size, session_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SendAsyncRequestWithUserBuffer64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t message_buffer = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t message_buffer_size = Convert<uint32_t>(GetArg32(args, 2));
    Handle session_handle = Convert<Handle>(GetArg32(args, 3));
    Handle out_event_handle{};
    Result ret = SendAsyncRequestWithUserBuffer64From32(system, std::addressof(out_event_handle), message_buffer, message_buffer_size, session_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_event_handle));
}

static void SvcWrap_GetProcessId64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    uint64_t out_process_id{};
    Result ret = GetProcessId64From32(system, std::addressof(out_process_id), process_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_process_id_scatter = Convert<std::array<uint32_t, 2>>(out_process_id);
    SetArg32(args, 1, out_process_id_scatter[0]);
    SetArg32(args, 2, out_process_id_scatter[1]);
}

static void SvcWrap_GetThreadId64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 1));
    uint64_t out_thread_id{};
    Result ret = GetThreadId64From32(system, std::addressof(out_thread_id), thread_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_thread_id_scatter = Convert<std::array<uint32_t, 2>>(out_thread_id);
    SetArg32(args, 1, out_thread_id_scatter[0]);
    SetArg32(args, 2, out_thread_id_scatter[1]);
}

static void SvcWrap_Break64From32(Core::System& system, std::span<uint64_t, 8> args) {
    BreakReason break_reason = Convert<BreakReason>(GetArg32(args, 0));
    uint32_t arg = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Break64From32(system, break_reason, arg, size);
}

static void SvcWrap_OutputDebugString64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t debug_str = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t len = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = OutputDebugString64From32(system, debug_str, len);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ReturnFromException64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Result result = Convert<Result>(GetArg32(args, 0));
    ReturnFromException64From32(system, result);
}

static void SvcWrap_GetInfo64From32(Core::System& system, std::span<uint64_t, 8> args) {
    InfoType info_type = Convert<InfoType>(GetArg32(args, 1));
    Handle handle = Convert<Handle>(GetArg32(args, 2));
    std::array<uint32_t, 2> info_subtype_gather{};
    info_subtype_gather[0] = GetArg32(args, 0);
    info_subtype_gather[1] = GetArg32(args, 3);
    uint64_t info_subtype = Convert<uint64_t>(info_subtype_gather);
    uint64_t out{};
    Result ret = GetInfo64From32(system, std::addressof(out), info_type, handle, info_subtype);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_scatter = Convert<std::array<uint32_t, 2>>(out);
    SetArg32(args, 1, out_scatter[0]);
    SetArg32(args, 2, out_scatter[1]);
}

static void SvcWrap_FlushEntireDataCache64From32(Core::System& system, std::span<uint64_t, 8> args) {
    FlushEntireDataCache64From32(system);
}

static void SvcWrap_FlushDataCache64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = FlushDataCache64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapPhysicalMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = MapPhysicalMemory64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapPhysicalMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = UnmapPhysicalMemory64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetDebugFutureThreadInfo64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 2));
    std::array<uint32_t, 2> ns_gather{};
    ns_gather[0] = GetArg32(args, 0);
    ns_gather[1] = GetArg32(args, 1);
    int64_t ns = Convert<int64_t>(ns_gather);
    ilp32::LastThreadContext out_context{};
    uint64_t out_thread_id{};
    Result ret = GetDebugFutureThreadInfo64From32(system, std::addressof(out_context), std::addressof(out_thread_id), debug_handle, ns);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_context_scatter = Convert<std::array<uint32_t, 4>>(out_context);
    SetArg32(args, 1, out_context_scatter[0]);
    SetArg32(args, 2, out_context_scatter[1]);
    SetArg32(args, 3, out_context_scatter[2]);
    SetArg32(args, 4, out_context_scatter[3]);
    auto out_thread_id_scatter = Convert<std::array<uint32_t, 2>>(out_thread_id);
    SetArg32(args, 5, out_thread_id_scatter[0]);
    SetArg32(args, 6, out_thread_id_scatter[1]);
}

static void SvcWrap_GetLastThreadInfo64From32(Core::System& system, std::span<uint64_t, 8> args) {
    ilp32::LastThreadContext out_context{};
    uint64_t out_tls_address{};
    uint32_t out_flags{};
    Result ret = GetLastThreadInfo64From32(system, std::addressof(out_context), std::addressof(out_tls_address), std::addressof(out_flags));
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_context_scatter = Convert<std::array<uint32_t, 4>>(out_context);
    SetArg32(args, 1, out_context_scatter[0]);
    SetArg32(args, 2, out_context_scatter[1]);
    SetArg32(args, 3, out_context_scatter[2]);
    SetArg32(args, 4, out_context_scatter[3]);
    SetArg32(args, 5, Convert<uint32_t>(out_tls_address));
    SetArg32(args, 6, Convert<uint32_t>(out_flags));
}

static void SvcWrap_GetResourceLimitLimitValue64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg32(args, 1));
    LimitableResource which = Convert<LimitableResource>(GetArg32(args, 2));
    int64_t out_limit_value{};
    Result ret = GetResourceLimitLimitValue64From32(system, std::addressof(out_limit_value), resource_limit_handle, which);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_limit_value_scatter = Convert<std::array<uint32_t, 2>>(out_limit_value);
    SetArg32(args, 1, out_limit_value_scatter[0]);
    SetArg32(args, 2, out_limit_value_scatter[1]);
}

static void SvcWrap_GetResourceLimitCurrentValue64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg32(args, 1));
    LimitableResource which = Convert<LimitableResource>(GetArg32(args, 2));
    int64_t out_current_value{};
    Result ret = GetResourceLimitCurrentValue64From32(system, std::addressof(out_current_value), resource_limit_handle, which);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_current_value_scatter = Convert<std::array<uint32_t, 2>>(out_current_value);
    SetArg32(args, 1, out_current_value_scatter[0]);
    SetArg32(args, 2, out_current_value_scatter[1]);
}

static void SvcWrap_SetThreadActivity64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg32(args, 0));
    ThreadActivity thread_activity = Convert<ThreadActivity>(GetArg32(args, 1));
    Result ret = SetThreadActivity64From32(system, thread_handle, thread_activity);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetThreadContext364From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_context = Convert<uint32_t>(GetArg32(args, 0));
    Handle thread_handle = Convert<Handle>(GetArg32(args, 1));
    Result ret = GetThreadContext364From32(system, out_context, thread_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_WaitForAddress64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    ArbitrationType arb_type = Convert<ArbitrationType>(GetArg32(args, 1));
    int32_t value = Convert<int32_t>(GetArg32(args, 2));
    std::array<uint32_t, 2> timeout_ns_gather{};
    timeout_ns_gather[0] = GetArg32(args, 3);
    timeout_ns_gather[1] = GetArg32(args, 4);
    int64_t timeout_ns = Convert<int64_t>(timeout_ns_gather);
    Result ret = WaitForAddress64From32(system, address, arb_type, value, timeout_ns);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SignalToAddress64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    SignalType signal_type = Convert<SignalType>(GetArg32(args, 1));
    int32_t value = Convert<int32_t>(GetArg32(args, 2));
    int32_t count = Convert<int32_t>(GetArg32(args, 3));
    Result ret = SignalToAddress64From32(system, address, signal_type, value, count);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SynchronizePreemptionState64From32(Core::System& system, std::span<uint64_t, 8> args) {
    SynchronizePreemptionState64From32(system);
}

static void SvcWrap_GetResourceLimitPeakValue64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg32(args, 1));
    LimitableResource which = Convert<LimitableResource>(GetArg32(args, 2));
    int64_t out_peak_value{};
    Result ret = GetResourceLimitPeakValue64From32(system, std::addressof(out_peak_value), resource_limit_handle, which);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_peak_value_scatter = Convert<std::array<uint32_t, 2>>(out_peak_value);
    SetArg32(args, 1, out_peak_value_scatter[0]);
    SetArg32(args, 2, out_peak_value_scatter[1]);
}

static void SvcWrap_CreateIoPool64From32(Core::System& system, std::span<uint64_t, 8> args) {
    IoPoolType which = Convert<IoPoolType>(GetArg32(args, 1));
    Handle out_handle{};
    Result ret = CreateIoPool64From32(system, std::addressof(out_handle), which);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_CreateIoRegion64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle io_pool = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> physical_address_gather{};
    physical_address_gather[0] = GetArg32(args, 2);
    physical_address_gather[1] = GetArg32(args, 3);
    uint64_t physical_address = Convert<uint64_t>(physical_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 0));
    MemoryMapping mapping = Convert<MemoryMapping>(GetArg32(args, 4));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg32(args, 5));
    Handle out_handle{};
    Result ret = CreateIoRegion64From32(system, std::addressof(out_handle), io_pool, physical_address, size, mapping, perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_KernelDebug64From32(Core::System& system, std::span<uint64_t, 8> args) {
    KernelDebugType kern_debug_type = Convert<KernelDebugType>(GetArg32(args, 0));
    std::array<uint32_t, 2> arg0_gather{};
    arg0_gather[0] = GetArg32(args, 2);
    arg0_gather[1] = GetArg32(args, 3);
    uint64_t arg0 = Convert<uint64_t>(arg0_gather);
    std::array<uint32_t, 2> arg1_gather{};
    arg1_gather[0] = GetArg32(args, 1);
    arg1_gather[1] = GetArg32(args, 4);
    uint64_t arg1 = Convert<uint64_t>(arg1_gather);
    std::array<uint32_t, 2> arg2_gather{};
    arg2_gather[0] = GetArg32(args, 5);
    arg2_gather[1] = GetArg32(args, 6);
    uint64_t arg2 = Convert<uint64_t>(arg2_gather);
    KernelDebug64From32(system, kern_debug_type, arg0, arg1, arg2);
}

static void SvcWrap_ChangeKernelTraceState64From32(Core::System& system, std::span<uint64_t, 8> args) {
    KernelTraceState kern_trace_state = Convert<KernelTraceState>(GetArg32(args, 0));
    ChangeKernelTraceState64From32(system, kern_trace_state);
}

static void SvcWrap_CreateSession64From32(Core::System& system, std::span<uint64_t, 8> args) {
    bool is_light = Convert<bool>(GetArg32(args, 2));
    uint32_t name = Convert<uint32_t>(GetArg32(args, 3));
    Handle out_server_session_handle{};
    Handle out_client_session_handle{};
    Result ret = CreateSession64From32(system, std::addressof(out_server_session_handle), std::addressof(out_client_session_handle), is_light, name);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_server_session_handle));
    SetArg32(args, 2, Convert<uint32_t>(out_client_session_handle));
}

static void SvcWrap_AcceptSession64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle port = Convert<Handle>(GetArg32(args, 1));
    Handle out_handle{};
    Result ret = AcceptSession64From32(system, std::addressof(out_handle), port);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_ReplyAndReceive64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t handles = Convert<uint32_t>(GetArg32(args, 1));
    int32_t num_handles = Convert<int32_t>(GetArg32(args, 2));
    Handle reply_target = Convert<Handle>(GetArg32(args, 3));
    std::array<uint32_t, 2> timeout_ns_gather{};
    timeout_ns_gather[0] = GetArg32(args, 0);
    timeout_ns_gather[1] = GetArg32(args, 4);
    int64_t timeout_ns = Convert<int64_t>(timeout_ns_gather);
    int32_t out_index{};
    Result ret = ReplyAndReceive64From32(system, std::addressof(out_index), handles, num_handles, reply_target, timeout_ns);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_index));
}

static void SvcWrap_ReplyAndReceiveWithUserBuffer64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t message_buffer = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t message_buffer_size = Convert<uint32_t>(GetArg32(args, 2));
    uint32_t handles = Convert<uint32_t>(GetArg32(args, 3));
    int32_t num_handles = Convert<int32_t>(GetArg32(args, 0));
    Handle reply_target = Convert<Handle>(GetArg32(args, 4));
    std::array<uint32_t, 2> timeout_ns_gather{};
    timeout_ns_gather[0] = GetArg32(args, 5);
    timeout_ns_gather[1] = GetArg32(args, 6);
    int64_t timeout_ns = Convert<int64_t>(timeout_ns_gather);
    int32_t out_index{};
    Result ret = ReplyAndReceiveWithUserBuffer64From32(system, std::addressof(out_index), message_buffer, message_buffer_size, handles, num_handles, reply_target, timeout_ns);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_index));
}

static void SvcWrap_CreateEvent64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle out_write_handle{};
    Handle out_read_handle{};
    Result ret = CreateEvent64From32(system, std::addressof(out_write_handle), std::addressof(out_read_handle));
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_write_handle));
    SetArg32(args, 2, Convert<uint32_t>(out_read_handle));
}

static void SvcWrap_MapIoRegion64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle io_region = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg32(args, 3));
    Result ret = MapIoRegion64From32(system, io_region, address, size, perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapIoRegion64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle io_region = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Result ret = UnmapIoRegion64From32(system, io_region, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapPhysicalMemoryUnsafe64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = MapPhysicalMemoryUnsafe64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapPhysicalMemoryUnsafe64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = UnmapPhysicalMemoryUnsafe64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SetUnsafeLimit64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t limit = Convert<uint32_t>(GetArg32(args, 0));
    Result ret = SetUnsafeLimit64From32(system, limit);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_CreateCodeMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Handle out_handle{};
    Result ret = CreateCodeMemory64From32(system, std::addressof(out_handle), address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_ControlCodeMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle code_memory_handle = Convert<Handle>(GetArg32(args, 0));
    CodeMemoryOperation operation = Convert<CodeMemoryOperation>(GetArg32(args, 1));
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 2);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 4);
    size_gather[1] = GetArg32(args, 5);
    uint64_t size = Convert<uint64_t>(size_gather);
    MemoryPermission perm = Convert<MemoryPermission>(GetArg32(args, 6));
    Result ret = ControlCodeMemory64From32(system, code_memory_handle, operation, address, size, perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SleepSystem64From32(Core::System& system, std::span<uint64_t, 8> args) {
    SleepSystem64From32(system);
}

static void SvcWrap_ReadWriteRegister64From32(Core::System& system, std::span<uint64_t, 8> args) {
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 2);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    uint32_t mask = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t value = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t out_value{};
    Result ret = ReadWriteRegister64From32(system, std::addressof(out_value), address, mask, value);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_value));
}

static void SvcWrap_SetProcessActivity64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    ProcessActivity process_activity = Convert<ProcessActivity>(GetArg32(args, 1));
    Result ret = SetProcessActivity64From32(system, process_handle, process_activity);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_CreateSharedMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    MemoryPermission owner_perm = Convert<MemoryPermission>(GetArg32(args, 2));
    MemoryPermission remote_perm = Convert<MemoryPermission>(GetArg32(args, 3));
    Handle out_handle{};
    Result ret = CreateSharedMemory64From32(system, std::addressof(out_handle), size, owner_perm, remote_perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_MapTransferMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle trmem_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    MemoryPermission owner_perm = Convert<MemoryPermission>(GetArg32(args, 3));
    Result ret = MapTransferMemory64From32(system, trmem_handle, address, size, owner_perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapTransferMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle trmem_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 2));
    Result ret = UnmapTransferMemory64From32(system, trmem_handle, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_CreateInterruptEvent64From32(Core::System& system, std::span<uint64_t, 8> args) {
    int32_t interrupt_id = Convert<int32_t>(GetArg32(args, 1));
    InterruptType interrupt_type = Convert<InterruptType>(GetArg32(args, 2));
    Handle out_read_handle{};
    Result ret = CreateInterruptEvent64From32(system, std::addressof(out_read_handle), interrupt_id, interrupt_type);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_read_handle));
}

static void SvcWrap_QueryPhysicalAddress64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 1));
    ilp32::PhysicalMemoryInfo out_info{};
    Result ret = QueryPhysicalAddress64From32(system, std::addressof(out_info), address);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_info_scatter = Convert<std::array<uint32_t, 4>>(out_info);
    SetArg32(args, 1, out_info_scatter[0]);
    SetArg32(args, 2, out_info_scatter[1]);
    SetArg32(args, 3, out_info_scatter[2]);
    SetArg32(args, 4, out_info_scatter[3]);
}

static void SvcWrap_QueryIoMapping64From32(Core::System& system, std::span<uint64_t, 8> args) {
    std::array<uint32_t, 2> physical_address_gather{};
    physical_address_gather[0] = GetArg32(args, 2);
    physical_address_gather[1] = GetArg32(args, 3);
    uint64_t physical_address = Convert<uint64_t>(physical_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 0));
    uint64_t out_address{};
    uint64_t out_size{};
    Result ret = QueryIoMapping64From32(system, std::addressof(out_address), std::addressof(out_size), physical_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_address));
    SetArg32(args, 2, Convert<uint32_t>(out_size));
}

static void SvcWrap_CreateDeviceAddressSpace64From32(Core::System& system, std::span<uint64_t, 8> args) {
    std::array<uint32_t, 2> das_address_gather{};
    das_address_gather[0] = GetArg32(args, 2);
    das_address_gather[1] = GetArg32(args, 3);
    uint64_t das_address = Convert<uint64_t>(das_address_gather);
    std::array<uint32_t, 2> das_size_gather{};
    das_size_gather[0] = GetArg32(args, 0);
    das_size_gather[1] = GetArg32(args, 1);
    uint64_t das_size = Convert<uint64_t>(das_size_gather);
    Handle out_handle{};
    Result ret = CreateDeviceAddressSpace64From32(system, std::addressof(out_handle), das_address, das_size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_AttachDeviceAddressSpace64From32(Core::System& system, std::span<uint64_t, 8> args) {
    DeviceName device_name = Convert<DeviceName>(GetArg32(args, 0));
    Handle das_handle = Convert<Handle>(GetArg32(args, 1));
    Result ret = AttachDeviceAddressSpace64From32(system, device_name, das_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_DetachDeviceAddressSpace64From32(Core::System& system, std::span<uint64_t, 8> args) {
    DeviceName device_name = Convert<DeviceName>(GetArg32(args, 0));
    Handle das_handle = Convert<Handle>(GetArg32(args, 1));
    Result ret = DetachDeviceAddressSpace64From32(system, device_name, das_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapDeviceAddressSpaceByForce64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle das_handle = Convert<Handle>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> process_address_gather{};
    process_address_gather[0] = GetArg32(args, 2);
    process_address_gather[1] = GetArg32(args, 3);
    uint64_t process_address = Convert<uint64_t>(process_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 4));
    std::array<uint32_t, 2> device_address_gather{};
    device_address_gather[0] = GetArg32(args, 5);
    device_address_gather[1] = GetArg32(args, 6);
    uint64_t device_address = Convert<uint64_t>(device_address_gather);
    uint32_t option = Convert<uint32_t>(GetArg32(args, 7));
    Result ret = MapDeviceAddressSpaceByForce64From32(system, das_handle, process_handle, process_address, size, device_address, option);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapDeviceAddressSpaceAligned64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle das_handle = Convert<Handle>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> process_address_gather{};
    process_address_gather[0] = GetArg32(args, 2);
    process_address_gather[1] = GetArg32(args, 3);
    uint64_t process_address = Convert<uint64_t>(process_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 4));
    std::array<uint32_t, 2> device_address_gather{};
    device_address_gather[0] = GetArg32(args, 5);
    device_address_gather[1] = GetArg32(args, 6);
    uint64_t device_address = Convert<uint64_t>(device_address_gather);
    uint32_t option = Convert<uint32_t>(GetArg32(args, 7));
    Result ret = MapDeviceAddressSpaceAligned64From32(system, das_handle, process_handle, process_address, size, device_address, option);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapDeviceAddressSpace64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle das_handle = Convert<Handle>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> process_address_gather{};
    process_address_gather[0] = GetArg32(args, 2);
    process_address_gather[1] = GetArg32(args, 3);
    uint64_t process_address = Convert<uint64_t>(process_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 4));
    std::array<uint32_t, 2> device_address_gather{};
    device_address_gather[0] = GetArg32(args, 5);
    device_address_gather[1] = GetArg32(args, 6);
    uint64_t device_address = Convert<uint64_t>(device_address_gather);
    Result ret = UnmapDeviceAddressSpace64From32(system, das_handle, process_handle, process_address, size, device_address);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_InvalidateProcessDataCache64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 2);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 1);
    size_gather[1] = GetArg32(args, 4);
    uint64_t size = Convert<uint64_t>(size_gather);
    Result ret = InvalidateProcessDataCache64From32(system, process_handle, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_StoreProcessDataCache64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 2);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 1);
    size_gather[1] = GetArg32(args, 4);
    uint64_t size = Convert<uint64_t>(size_gather);
    Result ret = StoreProcessDataCache64From32(system, process_handle, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_FlushProcessDataCache64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 2);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 1);
    size_gather[1] = GetArg32(args, 4);
    uint64_t size = Convert<uint64_t>(size_gather);
    Result ret = FlushProcessDataCache64From32(system, process_handle, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_DebugActiveProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    std::array<uint32_t, 2> process_id_gather{};
    process_id_gather[0] = GetArg32(args, 2);
    process_id_gather[1] = GetArg32(args, 3);
    uint64_t process_id = Convert<uint64_t>(process_id_gather);
    Handle out_handle{};
    Result ret = DebugActiveProcess64From32(system, std::addressof(out_handle), process_id);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_BreakDebugProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = BreakDebugProcess64From32(system, debug_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_TerminateDebugProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = TerminateDebugProcess64From32(system, debug_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetDebugEvent64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_info = Convert<uint32_t>(GetArg32(args, 0));
    Handle debug_handle = Convert<Handle>(GetArg32(args, 1));
    Result ret = GetDebugEvent64From32(system, out_info, debug_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_ContinueDebugEvent64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t flags = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t thread_ids = Convert<uint32_t>(GetArg32(args, 2));
    int32_t num_thread_ids = Convert<int32_t>(GetArg32(args, 3));
    Result ret = ContinueDebugEvent64From32(system, debug_handle, flags, thread_ids, num_thread_ids);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetProcessList64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_process_ids = Convert<uint32_t>(GetArg32(args, 1));
    int32_t max_out_count = Convert<int32_t>(GetArg32(args, 2));
    int32_t out_num_processes{};
    Result ret = GetProcessList64From32(system, std::addressof(out_num_processes), out_process_ids, max_out_count);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_num_processes));
}

static void SvcWrap_GetThreadList64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_thread_ids = Convert<uint32_t>(GetArg32(args, 1));
    int32_t max_out_count = Convert<int32_t>(GetArg32(args, 2));
    Handle debug_handle = Convert<Handle>(GetArg32(args, 3));
    int32_t out_num_threads{};
    Result ret = GetThreadList64From32(system, std::addressof(out_num_threads), out_thread_ids, max_out_count, debug_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_num_threads));
}

static void SvcWrap_GetDebugThreadContext64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_context = Convert<uint32_t>(GetArg32(args, 0));
    Handle debug_handle = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> thread_id_gather{};
    thread_id_gather[0] = GetArg32(args, 2);
    thread_id_gather[1] = GetArg32(args, 3);
    uint64_t thread_id = Convert<uint64_t>(thread_id_gather);
    uint32_t context_flags = Convert<uint32_t>(GetArg32(args, 4));
    Result ret = GetDebugThreadContext64From32(system, out_context, debug_handle, thread_id, context_flags);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SetDebugThreadContext64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> thread_id_gather{};
    thread_id_gather[0] = GetArg32(args, 2);
    thread_id_gather[1] = GetArg32(args, 3);
    uint64_t thread_id = Convert<uint64_t>(thread_id_gather);
    uint32_t context = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t context_flags = Convert<uint32_t>(GetArg32(args, 4));
    Result ret = SetDebugThreadContext64From32(system, debug_handle, thread_id, context, context_flags);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_QueryDebugProcessMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_memory_info = Convert<uint32_t>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 2));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 3));
    PageInfo out_page_info{};
    Result ret = QueryDebugProcessMemory64From32(system, out_memory_info, std::addressof(out_page_info), process_handle, address);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_page_info));
}

static void SvcWrap_ReadDebugProcessMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t buffer = Convert<uint32_t>(GetArg32(args, 0));
    Handle debug_handle = Convert<Handle>(GetArg32(args, 1));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 2));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 3));
    Result ret = ReadDebugProcessMemory64From32(system, buffer, debug_handle, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_WriteDebugProcessMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 0));
    uint32_t buffer = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t address = Convert<uint32_t>(GetArg32(args, 2));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 3));
    Result ret = WriteDebugProcessMemory64From32(system, debug_handle, buffer, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SetHardwareBreakPoint64From32(Core::System& system, std::span<uint64_t, 8> args) {
    HardwareBreakPointRegisterName name = Convert<HardwareBreakPointRegisterName>(GetArg32(args, 0));
    std::array<uint32_t, 2> flags_gather{};
    flags_gather[0] = GetArg32(args, 2);
    flags_gather[1] = GetArg32(args, 3);
    uint64_t flags = Convert<uint64_t>(flags_gather);
    std::array<uint32_t, 2> value_gather{};
    value_gather[0] = GetArg32(args, 1);
    value_gather[1] = GetArg32(args, 4);
    uint64_t value = Convert<uint64_t>(value_gather);
    Result ret = SetHardwareBreakPoint64From32(system, name, flags, value);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetDebugThreadParam64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg32(args, 2));
    std::array<uint32_t, 2> thread_id_gather{};
    thread_id_gather[0] = GetArg32(args, 0);
    thread_id_gather[1] = GetArg32(args, 1);
    uint64_t thread_id = Convert<uint64_t>(thread_id_gather);
    DebugThreadParam param = Convert<DebugThreadParam>(GetArg32(args, 3));
    uint64_t out_64{};
    uint32_t out_32{};
    Result ret = GetDebugThreadParam64From32(system, std::addressof(out_64), std::addressof(out_32), debug_handle, thread_id, param);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_64_scatter = Convert<std::array<uint32_t, 2>>(out_64);
    SetArg32(args, 1, out_64_scatter[0]);
    SetArg32(args, 2, out_64_scatter[1]);
    SetArg32(args, 3, Convert<uint32_t>(out_32));
}

static void SvcWrap_GetSystemInfo64From32(Core::System& system, std::span<uint64_t, 8> args) {
    SystemInfoType info_type = Convert<SystemInfoType>(GetArg32(args, 1));
    Handle handle = Convert<Handle>(GetArg32(args, 2));
    std::array<uint32_t, 2> info_subtype_gather{};
    info_subtype_gather[0] = GetArg32(args, 0);
    info_subtype_gather[1] = GetArg32(args, 3);
    uint64_t info_subtype = Convert<uint64_t>(info_subtype_gather);
    uint64_t out{};
    Result ret = GetSystemInfo64From32(system, std::addressof(out), info_type, handle, info_subtype);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_scatter = Convert<std::array<uint32_t, 2>>(out);
    SetArg32(args, 1, out_scatter[0]);
    SetArg32(args, 2, out_scatter[1]);
}

static void SvcWrap_CreatePort64From32(Core::System& system, std::span<uint64_t, 8> args) {
    int32_t max_sessions = Convert<int32_t>(GetArg32(args, 2));
    bool is_light = Convert<bool>(GetArg32(args, 3));
    uint32_t name = Convert<uint32_t>(GetArg32(args, 0));
    Handle out_server_handle{};
    Handle out_client_handle{};
    Result ret = CreatePort64From32(system, std::addressof(out_server_handle), std::addressof(out_client_handle), max_sessions, is_light, name);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_server_handle));
    SetArg32(args, 2, Convert<uint32_t>(out_client_handle));
}

static void SvcWrap_ManageNamedPort64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t name = Convert<uint32_t>(GetArg32(args, 1));
    int32_t max_sessions = Convert<int32_t>(GetArg32(args, 2));
    Handle out_server_handle{};
    Result ret = ManageNamedPort64From32(system, std::addressof(out_server_handle), name, max_sessions);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_server_handle));
}

static void SvcWrap_ConnectToPort64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle port = Convert<Handle>(GetArg32(args, 1));
    Handle out_handle{};
    Result ret = ConnectToPort64From32(system, std::addressof(out_handle), port);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_SetProcessMemoryPermission64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 2);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 1);
    size_gather[1] = GetArg32(args, 4);
    uint64_t size = Convert<uint64_t>(size_gather);
    MemoryPermission perm = Convert<MemoryPermission>(GetArg32(args, 5));
    Result ret = SetProcessMemoryPermission64From32(system, process_handle, address, size, perm);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapProcessMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t dst_address = Convert<uint32_t>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> src_address_gather{};
    src_address_gather[0] = GetArg32(args, 2);
    src_address_gather[1] = GetArg32(args, 3);
    uint64_t src_address = Convert<uint64_t>(src_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 4));
    Result ret = MapProcessMemory64From32(system, dst_address, process_handle, src_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapProcessMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t dst_address = Convert<uint32_t>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    std::array<uint32_t, 2> src_address_gather{};
    src_address_gather[0] = GetArg32(args, 2);
    src_address_gather[1] = GetArg32(args, 3);
    uint64_t src_address = Convert<uint64_t>(src_address_gather);
    uint32_t size = Convert<uint32_t>(GetArg32(args, 4));
    Result ret = UnmapProcessMemory64From32(system, dst_address, process_handle, src_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_QueryProcessMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t out_memory_info = Convert<uint32_t>(GetArg32(args, 0));
    Handle process_handle = Convert<Handle>(GetArg32(args, 2));
    std::array<uint32_t, 2> address_gather{};
    address_gather[0] = GetArg32(args, 1);
    address_gather[1] = GetArg32(args, 3);
    uint64_t address = Convert<uint64_t>(address_gather);
    PageInfo out_page_info{};
    Result ret = QueryProcessMemory64From32(system, out_memory_info, std::addressof(out_page_info), process_handle, address);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_page_info));
}

static void SvcWrap_MapProcessCodeMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> dst_address_gather{};
    dst_address_gather[0] = GetArg32(args, 2);
    dst_address_gather[1] = GetArg32(args, 3);
    uint64_t dst_address = Convert<uint64_t>(dst_address_gather);
    std::array<uint32_t, 2> src_address_gather{};
    src_address_gather[0] = GetArg32(args, 1);
    src_address_gather[1] = GetArg32(args, 4);
    uint64_t src_address = Convert<uint64_t>(src_address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 5);
    size_gather[1] = GetArg32(args, 6);
    uint64_t size = Convert<uint64_t>(size_gather);
    Result ret = MapProcessCodeMemory64From32(system, process_handle, dst_address, src_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapProcessCodeMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    std::array<uint32_t, 2> dst_address_gather{};
    dst_address_gather[0] = GetArg32(args, 2);
    dst_address_gather[1] = GetArg32(args, 3);
    uint64_t dst_address = Convert<uint64_t>(dst_address_gather);
    std::array<uint32_t, 2> src_address_gather{};
    src_address_gather[0] = GetArg32(args, 1);
    src_address_gather[1] = GetArg32(args, 4);
    uint64_t src_address = Convert<uint64_t>(src_address_gather);
    std::array<uint32_t, 2> size_gather{};
    size_gather[0] = GetArg32(args, 5);
    size_gather[1] = GetArg32(args, 6);
    uint64_t size = Convert<uint64_t>(size_gather);
    Result ret = UnmapProcessCodeMemory64From32(system, process_handle, dst_address, src_address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_CreateProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t parameters = Convert<uint32_t>(GetArg32(args, 1));
    uint32_t caps = Convert<uint32_t>(GetArg32(args, 2));
    int32_t num_caps = Convert<int32_t>(GetArg32(args, 3));
    Handle out_handle{};
    Result ret = CreateProcess64From32(system, std::addressof(out_handle), parameters, caps, num_caps);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_StartProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    int32_t priority = Convert<int32_t>(GetArg32(args, 1));
    int32_t core_id = Convert<int32_t>(GetArg32(args, 2));
    std::array<uint32_t, 2> main_thread_stack_size_gather{};
    main_thread_stack_size_gather[0] = GetArg32(args, 3);
    main_thread_stack_size_gather[1] = GetArg32(args, 4);
    uint64_t main_thread_stack_size = Convert<uint64_t>(main_thread_stack_size_gather);
    Result ret = StartProcess64From32(system, process_handle, priority, core_id, main_thread_stack_size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_TerminateProcess64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 0));
    Result ret = TerminateProcess64From32(system, process_handle);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_GetProcessInfo64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg32(args, 1));
    ProcessInfoType info_type = Convert<ProcessInfoType>(GetArg32(args, 2));
    int64_t out_info{};
    Result ret = GetProcessInfo64From32(system, std::addressof(out_info), process_handle, info_type);
    SetArg32(args, 0, Convert<uint32_t>(ret));
    auto out_info_scatter = Convert<std::array<uint32_t, 2>>(out_info);
    SetArg32(args, 1, out_info_scatter[0]);
    SetArg32(args, 2, out_info_scatter[1]);
}

static void SvcWrap_CreateResourceLimit64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle out_handle{};
    Result ret = CreateResourceLimit64From32(system, std::addressof(out_handle));
    SetArg32(args, 0, Convert<uint32_t>(ret));
    SetArg32(args, 1, Convert<uint32_t>(out_handle));
}

static void SvcWrap_SetResourceLimitLimitValue64From32(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg32(args, 0));
    LimitableResource which = Convert<LimitableResource>(GetArg32(args, 1));
    std::array<uint32_t, 2> limit_value_gather{};
    limit_value_gather[0] = GetArg32(args, 2);
    limit_value_gather[1] = GetArg32(args, 3);
    int64_t limit_value = Convert<int64_t>(limit_value_gather);
    Result ret = SetResourceLimitLimitValue64From32(system, resource_limit_handle, which, limit_value);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_MapInsecureMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = MapInsecureMemory64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_UnmapInsecureMemory64From32(Core::System& system, std::span<uint64_t, 8> args) {
    uint32_t address = Convert<uint32_t>(GetArg32(args, 0));
    uint32_t size = Convert<uint32_t>(GetArg32(args, 1));
    Result ret = UnmapInsecureMemory64From32(system, address, size);
    SetArg32(args, 0, Convert<uint32_t>(ret));
}

static void SvcWrap_SetHeapSize64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t out_address{};
    Result ret = SetHeapSize64(system, std::addressof(out_address), size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_address));
}

static void SvcWrap_SetMemoryPermission64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg64(args, 2));
    Result ret = SetMemoryPermission64(system, address, size, perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SetMemoryAttribute64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    uint32_t mask = Convert<uint32_t>(GetArg64(args, 2));
    uint32_t attr = Convert<uint32_t>(GetArg64(args, 3));
    Result ret = SetMemoryAttribute64(system, address, size, mask, attr);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t dst_address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t src_address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = MapMemory64(system, dst_address, src_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t dst_address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t src_address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = UnmapMemory64(system, dst_address, src_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_QueryMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_memory_info = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 2));
    PageInfo out_page_info{};
    Result ret = QueryMemory64(system, out_memory_info, std::addressof(out_page_info), address);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_page_info));
}

static void SvcWrap_ExitProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    ExitProcess64(system);
}

static void SvcWrap_CreateThread64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t func = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t arg = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t stack_bottom = Convert<uint64_t>(GetArg64(args, 3));
    int32_t priority = Convert<int32_t>(GetArg64(args, 4));
    int32_t core_id = Convert<int32_t>(GetArg64(args, 5));
    Handle out_handle{};
    Result ret = CreateThread64(system, std::addressof(out_handle), func, arg, stack_bottom, priority, core_id);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_StartThread64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = StartThread64(system, thread_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ExitThread64(Core::System& system, std::span<uint64_t, 8> args) {
    ExitThread64(system);
}

static void SvcWrap_SleepThread64(Core::System& system, std::span<uint64_t, 8> args) {
    int64_t ns = Convert<int64_t>(GetArg64(args, 0));
    SleepThread64(system, ns);
}

static void SvcWrap_GetThreadPriority64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 1));
    int32_t out_priority{};
    Result ret = GetThreadPriority64(system, std::addressof(out_priority), thread_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_priority));
}

static void SvcWrap_SetThreadPriority64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 0));
    int32_t priority = Convert<int32_t>(GetArg64(args, 1));
    Result ret = SetThreadPriority64(system, thread_handle, priority);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetThreadCoreMask64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 2));
    int32_t out_core_id{};
    uint64_t out_affinity_mask{};
    Result ret = GetThreadCoreMask64(system, std::addressof(out_core_id), std::addressof(out_affinity_mask), thread_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_core_id));
    SetArg64(args, 2, Convert<uint64_t>(out_affinity_mask));
}

static void SvcWrap_SetThreadCoreMask64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 0));
    int32_t core_id = Convert<int32_t>(GetArg64(args, 1));
    uint64_t affinity_mask = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = SetThreadCoreMask64(system, thread_handle, core_id, affinity_mask);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetCurrentProcessorNumber64(Core::System& system, std::span<uint64_t, 8> args) {
    int32_t ret = GetCurrentProcessorNumber64(system);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SignalEvent64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle event_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = SignalEvent64(system, event_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ClearEvent64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle event_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = ClearEvent64(system, event_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapSharedMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle shmem_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    MemoryPermission map_perm = Convert<MemoryPermission>(GetArg64(args, 3));
    Result ret = MapSharedMemory64(system, shmem_handle, address, size, map_perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapSharedMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle shmem_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = UnmapSharedMemory64(system, shmem_handle, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_CreateTransferMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    MemoryPermission map_perm = Convert<MemoryPermission>(GetArg64(args, 3));
    Handle out_handle{};
    Result ret = CreateTransferMemory64(system, std::addressof(out_handle), address, size, map_perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_CloseHandle64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = CloseHandle64(system, handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ResetSignal64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = ResetSignal64(system, handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_WaitSynchronization64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t handles = Convert<uint64_t>(GetArg64(args, 1));
    int32_t num_handles = Convert<int32_t>(GetArg64(args, 2));
    int64_t timeout_ns = Convert<int64_t>(GetArg64(args, 3));
    int32_t out_index{};
    Result ret = WaitSynchronization64(system, std::addressof(out_index), handles, num_handles, timeout_ns);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_index));
}

static void SvcWrap_CancelSynchronization64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = CancelSynchronization64(system, handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ArbitrateLock64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint32_t tag = Convert<uint32_t>(GetArg64(args, 2));
    Result ret = ArbitrateLock64(system, thread_handle, address, tag);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ArbitrateUnlock64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    Result ret = ArbitrateUnlock64(system, address);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_WaitProcessWideKeyAtomic64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t cv_key = Convert<uint64_t>(GetArg64(args, 1));
    uint32_t tag = Convert<uint32_t>(GetArg64(args, 2));
    int64_t timeout_ns = Convert<int64_t>(GetArg64(args, 3));
    Result ret = WaitProcessWideKeyAtomic64(system, address, cv_key, tag, timeout_ns);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SignalProcessWideKey64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t cv_key = Convert<uint64_t>(GetArg64(args, 0));
    int32_t count = Convert<int32_t>(GetArg64(args, 1));
    SignalProcessWideKey64(system, cv_key, count);
}

static void SvcWrap_GetSystemTick64(Core::System& system, std::span<uint64_t, 8> args) {
    int64_t ret = GetSystemTick64(system);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ConnectToNamedPort64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t name = Convert<uint64_t>(GetArg64(args, 1));
    Handle out_handle{};
    Result ret = ConnectToNamedPort64(system, std::addressof(out_handle), name);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_SendSyncRequest64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle session_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = SendSyncRequest64(system, session_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SendSyncRequestWithUserBuffer64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t message_buffer = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t message_buffer_size = Convert<uint64_t>(GetArg64(args, 1));
    Handle session_handle = Convert<Handle>(GetArg64(args, 2));
    Result ret = SendSyncRequestWithUserBuffer64(system, message_buffer, message_buffer_size, session_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SendAsyncRequestWithUserBuffer64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t message_buffer = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t message_buffer_size = Convert<uint64_t>(GetArg64(args, 2));
    Handle session_handle = Convert<Handle>(GetArg64(args, 3));
    Handle out_event_handle{};
    Result ret = SendAsyncRequestWithUserBuffer64(system, std::addressof(out_event_handle), message_buffer, message_buffer_size, session_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_event_handle));
}

static void SvcWrap_GetProcessId64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t out_process_id{};
    Result ret = GetProcessId64(system, std::addressof(out_process_id), process_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_process_id));
}

static void SvcWrap_GetThreadId64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t out_thread_id{};
    Result ret = GetThreadId64(system, std::addressof(out_thread_id), thread_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_thread_id));
}

static void SvcWrap_Break64(Core::System& system, std::span<uint64_t, 8> args) {
    BreakReason break_reason = Convert<BreakReason>(GetArg64(args, 0));
    uint64_t arg = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Break64(system, break_reason, arg, size);
}

static void SvcWrap_OutputDebugString64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t debug_str = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t len = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = OutputDebugString64(system, debug_str, len);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ReturnFromException64(Core::System& system, std::span<uint64_t, 8> args) {
    Result result = Convert<Result>(GetArg64(args, 0));
    ReturnFromException64(system, result);
}

static void SvcWrap_GetInfo64(Core::System& system, std::span<uint64_t, 8> args) {
    InfoType info_type = Convert<InfoType>(GetArg64(args, 1));
    Handle handle = Convert<Handle>(GetArg64(args, 2));
    uint64_t info_subtype = Convert<uint64_t>(GetArg64(args, 3));
    uint64_t out{};
    Result ret = GetInfo64(system, std::addressof(out), info_type, handle, info_subtype);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out));
}

static void SvcWrap_FlushEntireDataCache64(Core::System& system, std::span<uint64_t, 8> args) {
    FlushEntireDataCache64(system);
}

static void SvcWrap_FlushDataCache64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = FlushDataCache64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapPhysicalMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = MapPhysicalMemory64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapPhysicalMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = UnmapPhysicalMemory64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetDebugFutureThreadInfo64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 2));
    int64_t ns = Convert<int64_t>(GetArg64(args, 3));
    lp64::LastThreadContext out_context{};
    uint64_t out_thread_id{};
    Result ret = GetDebugFutureThreadInfo64(system, std::addressof(out_context), std::addressof(out_thread_id), debug_handle, ns);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    auto out_context_scatter = Convert<std::array<uint64_t, 4>>(out_context);
    SetArg64(args, 1, out_context_scatter[0]);
    SetArg64(args, 2, out_context_scatter[1]);
    SetArg64(args, 3, out_context_scatter[2]);
    SetArg64(args, 4, out_context_scatter[3]);
    SetArg64(args, 5, Convert<uint64_t>(out_thread_id));
}

static void SvcWrap_GetLastThreadInfo64(Core::System& system, std::span<uint64_t, 8> args) {
    lp64::LastThreadContext out_context{};
    uint64_t out_tls_address{};
    uint32_t out_flags{};
    Result ret = GetLastThreadInfo64(system, std::addressof(out_context), std::addressof(out_tls_address), std::addressof(out_flags));
    SetArg64(args, 0, Convert<uint64_t>(ret));
    auto out_context_scatter = Convert<std::array<uint64_t, 4>>(out_context);
    SetArg64(args, 1, out_context_scatter[0]);
    SetArg64(args, 2, out_context_scatter[1]);
    SetArg64(args, 3, out_context_scatter[2]);
    SetArg64(args, 4, out_context_scatter[3]);
    SetArg64(args, 5, Convert<uint64_t>(out_tls_address));
    SetArg64(args, 6, Convert<uint64_t>(out_flags));
}

static void SvcWrap_GetResourceLimitLimitValue64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg64(args, 1));
    LimitableResource which = Convert<LimitableResource>(GetArg64(args, 2));
    int64_t out_limit_value{};
    Result ret = GetResourceLimitLimitValue64(system, std::addressof(out_limit_value), resource_limit_handle, which);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_limit_value));
}

static void SvcWrap_GetResourceLimitCurrentValue64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg64(args, 1));
    LimitableResource which = Convert<LimitableResource>(GetArg64(args, 2));
    int64_t out_current_value{};
    Result ret = GetResourceLimitCurrentValue64(system, std::addressof(out_current_value), resource_limit_handle, which);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_current_value));
}

static void SvcWrap_SetThreadActivity64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle thread_handle = Convert<Handle>(GetArg64(args, 0));
    ThreadActivity thread_activity = Convert<ThreadActivity>(GetArg64(args, 1));
    Result ret = SetThreadActivity64(system, thread_handle, thread_activity);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetThreadContext364(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_context = Convert<uint64_t>(GetArg64(args, 0));
    Handle thread_handle = Convert<Handle>(GetArg64(args, 1));
    Result ret = GetThreadContext364(system, out_context, thread_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_WaitForAddress64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    ArbitrationType arb_type = Convert<ArbitrationType>(GetArg64(args, 1));
    int32_t value = Convert<int32_t>(GetArg64(args, 2));
    int64_t timeout_ns = Convert<int64_t>(GetArg64(args, 3));
    Result ret = WaitForAddress64(system, address, arb_type, value, timeout_ns);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SignalToAddress64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    SignalType signal_type = Convert<SignalType>(GetArg64(args, 1));
    int32_t value = Convert<int32_t>(GetArg64(args, 2));
    int32_t count = Convert<int32_t>(GetArg64(args, 3));
    Result ret = SignalToAddress64(system, address, signal_type, value, count);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SynchronizePreemptionState64(Core::System& system, std::span<uint64_t, 8> args) {
    SynchronizePreemptionState64(system);
}

static void SvcWrap_GetResourceLimitPeakValue64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg64(args, 1));
    LimitableResource which = Convert<LimitableResource>(GetArg64(args, 2));
    int64_t out_peak_value{};
    Result ret = GetResourceLimitPeakValue64(system, std::addressof(out_peak_value), resource_limit_handle, which);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_peak_value));
}

static void SvcWrap_CreateIoPool64(Core::System& system, std::span<uint64_t, 8> args) {
    IoPoolType which = Convert<IoPoolType>(GetArg64(args, 1));
    Handle out_handle{};
    Result ret = CreateIoPool64(system, std::addressof(out_handle), which);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_CreateIoRegion64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle io_pool = Convert<Handle>(GetArg64(args, 1));
    uint64_t physical_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    MemoryMapping mapping = Convert<MemoryMapping>(GetArg64(args, 4));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg64(args, 5));
    Handle out_handle{};
    Result ret = CreateIoRegion64(system, std::addressof(out_handle), io_pool, physical_address, size, mapping, perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_KernelDebug64(Core::System& system, std::span<uint64_t, 8> args) {
    KernelDebugType kern_debug_type = Convert<KernelDebugType>(GetArg64(args, 0));
    uint64_t arg0 = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t arg1 = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t arg2 = Convert<uint64_t>(GetArg64(args, 3));
    KernelDebug64(system, kern_debug_type, arg0, arg1, arg2);
}

static void SvcWrap_ChangeKernelTraceState64(Core::System& system, std::span<uint64_t, 8> args) {
    KernelTraceState kern_trace_state = Convert<KernelTraceState>(GetArg64(args, 0));
    ChangeKernelTraceState64(system, kern_trace_state);
}

static void SvcWrap_CreateSession64(Core::System& system, std::span<uint64_t, 8> args) {
    bool is_light = Convert<bool>(GetArg64(args, 2));
    uint64_t name = Convert<uint64_t>(GetArg64(args, 3));
    Handle out_server_session_handle{};
    Handle out_client_session_handle{};
    Result ret = CreateSession64(system, std::addressof(out_server_session_handle), std::addressof(out_client_session_handle), is_light, name);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_server_session_handle));
    SetArg64(args, 2, Convert<uint64_t>(out_client_session_handle));
}

static void SvcWrap_AcceptSession64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle port = Convert<Handle>(GetArg64(args, 1));
    Handle out_handle{};
    Result ret = AcceptSession64(system, std::addressof(out_handle), port);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_ReplyAndReceive64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t handles = Convert<uint64_t>(GetArg64(args, 1));
    int32_t num_handles = Convert<int32_t>(GetArg64(args, 2));
    Handle reply_target = Convert<Handle>(GetArg64(args, 3));
    int64_t timeout_ns = Convert<int64_t>(GetArg64(args, 4));
    int32_t out_index{};
    Result ret = ReplyAndReceive64(system, std::addressof(out_index), handles, num_handles, reply_target, timeout_ns);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_index));
}

static void SvcWrap_ReplyAndReceiveWithUserBuffer64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t message_buffer = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t message_buffer_size = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t handles = Convert<uint64_t>(GetArg64(args, 3));
    int32_t num_handles = Convert<int32_t>(GetArg64(args, 4));
    Handle reply_target = Convert<Handle>(GetArg64(args, 5));
    int64_t timeout_ns = Convert<int64_t>(GetArg64(args, 6));
    int32_t out_index{};
    Result ret = ReplyAndReceiveWithUserBuffer64(system, std::addressof(out_index), message_buffer, message_buffer_size, handles, num_handles, reply_target, timeout_ns);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_index));
}

static void SvcWrap_CreateEvent64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle out_write_handle{};
    Handle out_read_handle{};
    Result ret = CreateEvent64(system, std::addressof(out_write_handle), std::addressof(out_read_handle));
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_write_handle));
    SetArg64(args, 2, Convert<uint64_t>(out_read_handle));
}

static void SvcWrap_MapIoRegion64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle io_region = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg64(args, 3));
    Result ret = MapIoRegion64(system, io_region, address, size, perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapIoRegion64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle io_region = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = UnmapIoRegion64(system, io_region, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapPhysicalMemoryUnsafe64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = MapPhysicalMemoryUnsafe64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapPhysicalMemoryUnsafe64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = UnmapPhysicalMemoryUnsafe64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SetUnsafeLimit64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t limit = Convert<uint64_t>(GetArg64(args, 0));
    Result ret = SetUnsafeLimit64(system, limit);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_CreateCodeMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Handle out_handle{};
    Result ret = CreateCodeMemory64(system, std::addressof(out_handle), address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_ControlCodeMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle code_memory_handle = Convert<Handle>(GetArg64(args, 0));
    CodeMemoryOperation operation = Convert<CodeMemoryOperation>(GetArg64(args, 1));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg64(args, 4));
    Result ret = ControlCodeMemory64(system, code_memory_handle, operation, address, size, perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SleepSystem64(Core::System& system, std::span<uint64_t, 8> args) {
    SleepSystem64(system);
}

static void SvcWrap_ReadWriteRegister64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint32_t mask = Convert<uint32_t>(GetArg64(args, 2));
    uint32_t value = Convert<uint32_t>(GetArg64(args, 3));
    uint32_t out_value{};
    Result ret = ReadWriteRegister64(system, std::addressof(out_value), address, mask, value);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_value));
}

static void SvcWrap_SetProcessActivity64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    ProcessActivity process_activity = Convert<ProcessActivity>(GetArg64(args, 1));
    Result ret = SetProcessActivity64(system, process_handle, process_activity);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_CreateSharedMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    MemoryPermission owner_perm = Convert<MemoryPermission>(GetArg64(args, 2));
    MemoryPermission remote_perm = Convert<MemoryPermission>(GetArg64(args, 3));
    Handle out_handle{};
    Result ret = CreateSharedMemory64(system, std::addressof(out_handle), size, owner_perm, remote_perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_MapTransferMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle trmem_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    MemoryPermission owner_perm = Convert<MemoryPermission>(GetArg64(args, 3));
    Result ret = MapTransferMemory64(system, trmem_handle, address, size, owner_perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapTransferMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle trmem_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = UnmapTransferMemory64(system, trmem_handle, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_CreateInterruptEvent64(Core::System& system, std::span<uint64_t, 8> args) {
    int32_t interrupt_id = Convert<int32_t>(GetArg64(args, 1));
    InterruptType interrupt_type = Convert<InterruptType>(GetArg64(args, 2));
    Handle out_read_handle{};
    Result ret = CreateInterruptEvent64(system, std::addressof(out_read_handle), interrupt_id, interrupt_type);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_read_handle));
}

static void SvcWrap_QueryPhysicalAddress64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    lp64::PhysicalMemoryInfo out_info{};
    Result ret = QueryPhysicalAddress64(system, std::addressof(out_info), address);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    auto out_info_scatter = Convert<std::array<uint64_t, 3>>(out_info);
    SetArg64(args, 1, out_info_scatter[0]);
    SetArg64(args, 2, out_info_scatter[1]);
    SetArg64(args, 3, out_info_scatter[2]);
}

static void SvcWrap_QueryIoMapping64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t physical_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    uint64_t out_address{};
    uint64_t out_size{};
    Result ret = QueryIoMapping64(system, std::addressof(out_address), std::addressof(out_size), physical_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_address));
    SetArg64(args, 2, Convert<uint64_t>(out_size));
}

static void SvcWrap_CreateDeviceAddressSpace64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t das_address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t das_size = Convert<uint64_t>(GetArg64(args, 2));
    Handle out_handle{};
    Result ret = CreateDeviceAddressSpace64(system, std::addressof(out_handle), das_address, das_size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_AttachDeviceAddressSpace64(Core::System& system, std::span<uint64_t, 8> args) {
    DeviceName device_name = Convert<DeviceName>(GetArg64(args, 0));
    Handle das_handle = Convert<Handle>(GetArg64(args, 1));
    Result ret = AttachDeviceAddressSpace64(system, device_name, das_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_DetachDeviceAddressSpace64(Core::System& system, std::span<uint64_t, 8> args) {
    DeviceName device_name = Convert<DeviceName>(GetArg64(args, 0));
    Handle das_handle = Convert<Handle>(GetArg64(args, 1));
    Result ret = DetachDeviceAddressSpace64(system, device_name, das_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapDeviceAddressSpaceByForce64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle das_handle = Convert<Handle>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t process_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    uint64_t device_address = Convert<uint64_t>(GetArg64(args, 4));
    uint32_t option = Convert<uint32_t>(GetArg64(args, 5));
    Result ret = MapDeviceAddressSpaceByForce64(system, das_handle, process_handle, process_address, size, device_address, option);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapDeviceAddressSpaceAligned64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle das_handle = Convert<Handle>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t process_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    uint64_t device_address = Convert<uint64_t>(GetArg64(args, 4));
    uint32_t option = Convert<uint32_t>(GetArg64(args, 5));
    Result ret = MapDeviceAddressSpaceAligned64(system, das_handle, process_handle, process_address, size, device_address, option);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapDeviceAddressSpace64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle das_handle = Convert<Handle>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t process_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    uint64_t device_address = Convert<uint64_t>(GetArg64(args, 4));
    Result ret = UnmapDeviceAddressSpace64(system, das_handle, process_handle, process_address, size, device_address);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_InvalidateProcessDataCache64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = InvalidateProcessDataCache64(system, process_handle, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_StoreProcessDataCache64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = StoreProcessDataCache64(system, process_handle, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_FlushProcessDataCache64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = FlushProcessDataCache64(system, process_handle, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_DebugActiveProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t process_id = Convert<uint64_t>(GetArg64(args, 1));
    Handle out_handle{};
    Result ret = DebugActiveProcess64(system, std::addressof(out_handle), process_id);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_BreakDebugProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = BreakDebugProcess64(system, debug_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_TerminateDebugProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = TerminateDebugProcess64(system, debug_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetDebugEvent64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_info = Convert<uint64_t>(GetArg64(args, 0));
    Handle debug_handle = Convert<Handle>(GetArg64(args, 1));
    Result ret = GetDebugEvent64(system, out_info, debug_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_ContinueDebugEvent64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 0));
    uint32_t flags = Convert<uint32_t>(GetArg64(args, 1));
    uint64_t thread_ids = Convert<uint64_t>(GetArg64(args, 2));
    int32_t num_thread_ids = Convert<int32_t>(GetArg64(args, 3));
    Result ret = ContinueDebugEvent64(system, debug_handle, flags, thread_ids, num_thread_ids);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetProcessList64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_process_ids = Convert<uint64_t>(GetArg64(args, 1));
    int32_t max_out_count = Convert<int32_t>(GetArg64(args, 2));
    int32_t out_num_processes{};
    Result ret = GetProcessList64(system, std::addressof(out_num_processes), out_process_ids, max_out_count);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_num_processes));
}

static void SvcWrap_GetThreadList64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_thread_ids = Convert<uint64_t>(GetArg64(args, 1));
    int32_t max_out_count = Convert<int32_t>(GetArg64(args, 2));
    Handle debug_handle = Convert<Handle>(GetArg64(args, 3));
    int32_t out_num_threads{};
    Result ret = GetThreadList64(system, std::addressof(out_num_threads), out_thread_ids, max_out_count, debug_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_num_threads));
}

static void SvcWrap_GetDebugThreadContext64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_context = Convert<uint64_t>(GetArg64(args, 0));
    Handle debug_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t thread_id = Convert<uint64_t>(GetArg64(args, 2));
    uint32_t context_flags = Convert<uint32_t>(GetArg64(args, 3));
    Result ret = GetDebugThreadContext64(system, out_context, debug_handle, thread_id, context_flags);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SetDebugThreadContext64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t thread_id = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t context = Convert<uint64_t>(GetArg64(args, 2));
    uint32_t context_flags = Convert<uint32_t>(GetArg64(args, 3));
    Result ret = SetDebugThreadContext64(system, debug_handle, thread_id, context, context_flags);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_QueryDebugProcessMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_memory_info = Convert<uint64_t>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 2));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 3));
    PageInfo out_page_info{};
    Result ret = QueryDebugProcessMemory64(system, out_memory_info, std::addressof(out_page_info), process_handle, address);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_page_info));
}

static void SvcWrap_ReadDebugProcessMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t buffer = Convert<uint64_t>(GetArg64(args, 0));
    Handle debug_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = ReadDebugProcessMemory64(system, buffer, debug_handle, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_WriteDebugProcessMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t buffer = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = WriteDebugProcessMemory64(system, debug_handle, buffer, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_SetHardwareBreakPoint64(Core::System& system, std::span<uint64_t, 8> args) {
    HardwareBreakPointRegisterName name = Convert<HardwareBreakPointRegisterName>(GetArg64(args, 0));
    uint64_t flags = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t value = Convert<uint64_t>(GetArg64(args, 2));
    Result ret = SetHardwareBreakPoint64(system, name, flags, value);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetDebugThreadParam64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle debug_handle = Convert<Handle>(GetArg64(args, 2));
    uint64_t thread_id = Convert<uint64_t>(GetArg64(args, 3));
    DebugThreadParam param = Convert<DebugThreadParam>(GetArg64(args, 4));
    uint64_t out_64{};
    uint32_t out_32{};
    Result ret = GetDebugThreadParam64(system, std::addressof(out_64), std::addressof(out_32), debug_handle, thread_id, param);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_64));
    SetArg64(args, 2, Convert<uint64_t>(out_32));
}

static void SvcWrap_GetSystemInfo64(Core::System& system, std::span<uint64_t, 8> args) {
    SystemInfoType info_type = Convert<SystemInfoType>(GetArg64(args, 1));
    Handle handle = Convert<Handle>(GetArg64(args, 2));
    uint64_t info_subtype = Convert<uint64_t>(GetArg64(args, 3));
    uint64_t out{};
    Result ret = GetSystemInfo64(system, std::addressof(out), info_type, handle, info_subtype);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out));
}

static void SvcWrap_CreatePort64(Core::System& system, std::span<uint64_t, 8> args) {
    int32_t max_sessions = Convert<int32_t>(GetArg64(args, 2));
    bool is_light = Convert<bool>(GetArg64(args, 3));
    uint64_t name = Convert<uint64_t>(GetArg64(args, 4));
    Handle out_server_handle{};
    Handle out_client_handle{};
    Result ret = CreatePort64(system, std::addressof(out_server_handle), std::addressof(out_client_handle), max_sessions, is_light, name);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_server_handle));
    SetArg64(args, 2, Convert<uint64_t>(out_client_handle));
}

static void SvcWrap_ManageNamedPort64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t name = Convert<uint64_t>(GetArg64(args, 1));
    int32_t max_sessions = Convert<int32_t>(GetArg64(args, 2));
    Handle out_server_handle{};
    Result ret = ManageNamedPort64(system, std::addressof(out_server_handle), name, max_sessions);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_server_handle));
}

static void SvcWrap_ConnectToPort64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle port = Convert<Handle>(GetArg64(args, 1));
    Handle out_handle{};
    Result ret = ConnectToPort64(system, std::addressof(out_handle), port);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_SetProcessMemoryPermission64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 2));
    MemoryPermission perm = Convert<MemoryPermission>(GetArg64(args, 3));
    Result ret = SetProcessMemoryPermission64(system, process_handle, address, size, perm);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapProcessMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t dst_address = Convert<uint64_t>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t src_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = MapProcessMemory64(system, dst_address, process_handle, src_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapProcessMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t dst_address = Convert<uint64_t>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    uint64_t src_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = UnmapProcessMemory64(system, dst_address, process_handle, src_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_QueryProcessMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t out_memory_info = Convert<uint64_t>(GetArg64(args, 0));
    Handle process_handle = Convert<Handle>(GetArg64(args, 2));
    uint64_t address = Convert<uint64_t>(GetArg64(args, 3));
    PageInfo out_page_info{};
    Result ret = QueryProcessMemory64(system, out_memory_info, std::addressof(out_page_info), process_handle, address);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_page_info));
}

static void SvcWrap_MapProcessCodeMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t dst_address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t src_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = MapProcessCodeMemory64(system, process_handle, dst_address, src_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapProcessCodeMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    uint64_t dst_address = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t src_address = Convert<uint64_t>(GetArg64(args, 2));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = UnmapProcessCodeMemory64(system, process_handle, dst_address, src_address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_CreateProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t parameters = Convert<uint64_t>(GetArg64(args, 1));
    uint64_t caps = Convert<uint64_t>(GetArg64(args, 2));
    int32_t num_caps = Convert<int32_t>(GetArg64(args, 3));
    Handle out_handle{};
    Result ret = CreateProcess64(system, std::addressof(out_handle), parameters, caps, num_caps);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_StartProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    int32_t priority = Convert<int32_t>(GetArg64(args, 1));
    int32_t core_id = Convert<int32_t>(GetArg64(args, 2));
    uint64_t main_thread_stack_size = Convert<uint64_t>(GetArg64(args, 3));
    Result ret = StartProcess64(system, process_handle, priority, core_id, main_thread_stack_size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_TerminateProcess64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 0));
    Result ret = TerminateProcess64(system, process_handle);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_GetProcessInfo64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle process_handle = Convert<Handle>(GetArg64(args, 1));
    ProcessInfoType info_type = Convert<ProcessInfoType>(GetArg64(args, 2));
    int64_t out_info{};
    Result ret = GetProcessInfo64(system, std::addressof(out_info), process_handle, info_type);
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_info));
}

static void SvcWrap_CreateResourceLimit64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle out_handle{};
    Result ret = CreateResourceLimit64(system, std::addressof(out_handle));
    SetArg64(args, 0, Convert<uint64_t>(ret));
    SetArg64(args, 1, Convert<uint64_t>(out_handle));
}

static void SvcWrap_SetResourceLimitLimitValue64(Core::System& system, std::span<uint64_t, 8> args) {
    Handle resource_limit_handle = Convert<Handle>(GetArg64(args, 0));
    LimitableResource which = Convert<LimitableResource>(GetArg64(args, 1));
    int64_t limit_value = Convert<int64_t>(GetArg64(args, 2));
    Result ret = SetResourceLimitLimitValue64(system, resource_limit_handle, which, limit_value);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_MapInsecureMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = MapInsecureMemory64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void SvcWrap_UnmapInsecureMemory64(Core::System& system, std::span<uint64_t, 8> args) {
    uint64_t address = Convert<uint64_t>(GetArg64(args, 0));
    uint64_t size = Convert<uint64_t>(GetArg64(args, 1));
    Result ret = UnmapInsecureMemory64(system, address, size);
    SetArg64(args, 0, Convert<uint64_t>(ret));
}

static void Call32(Core::System& system, u32 imm, std::span<uint64_t, 8> args) {
    switch (SvcId(imm)) {
    case SvcId::SetHeapSize: return SvcWrap_SetHeapSize64From32(system, args);
    case SvcId::SetMemoryPermission: return SvcWrap_SetMemoryPermission64From32(system, args);
    case SvcId::SetMemoryAttribute: return SvcWrap_SetMemoryAttribute64From32(system, args);
    case SvcId::MapMemory: return SvcWrap_MapMemory64From32(system, args);
    case SvcId::UnmapMemory: return SvcWrap_UnmapMemory64From32(system, args);
    case SvcId::QueryMemory: return SvcWrap_QueryMemory64From32(system, args);
    case SvcId::ExitProcess: return SvcWrap_ExitProcess64From32(system, args);
    case SvcId::CreateThread: return SvcWrap_CreateThread64From32(system, args);
    case SvcId::StartThread: return SvcWrap_StartThread64From32(system, args);
    case SvcId::ExitThread: return SvcWrap_ExitThread64From32(system, args);
    case SvcId::SleepThread: return SvcWrap_SleepThread64From32(system, args);
    case SvcId::GetThreadPriority: return SvcWrap_GetThreadPriority64From32(system, args);
    case SvcId::SetThreadPriority: return SvcWrap_SetThreadPriority64From32(system, args);
    case SvcId::GetThreadCoreMask: return SvcWrap_GetThreadCoreMask64From32(system, args);
    case SvcId::SetThreadCoreMask: return SvcWrap_SetThreadCoreMask64From32(system, args);
    case SvcId::GetCurrentProcessorNumber: return SvcWrap_GetCurrentProcessorNumber64From32(system, args);
    case SvcId::SignalEvent: return SvcWrap_SignalEvent64From32(system, args);
    case SvcId::ClearEvent: return SvcWrap_ClearEvent64From32(system, args);
    case SvcId::MapSharedMemory: return SvcWrap_MapSharedMemory64From32(system, args);
    case SvcId::UnmapSharedMemory: return SvcWrap_UnmapSharedMemory64From32(system, args);
    case SvcId::CreateTransferMemory: return SvcWrap_CreateTransferMemory64From32(system, args);
    case SvcId::CloseHandle: return SvcWrap_CloseHandle64From32(system, args);
    case SvcId::ResetSignal: return SvcWrap_ResetSignal64From32(system, args);
    case SvcId::WaitSynchronization: return SvcWrap_WaitSynchronization64From32(system, args);
    case SvcId::CancelSynchronization: return SvcWrap_CancelSynchronization64From32(system, args);
    case SvcId::ArbitrateLock: return SvcWrap_ArbitrateLock64From32(system, args);
    case SvcId::ArbitrateUnlock: return SvcWrap_ArbitrateUnlock64From32(system, args);
    case SvcId::WaitProcessWideKeyAtomic: return SvcWrap_WaitProcessWideKeyAtomic64From32(system, args);
    case SvcId::SignalProcessWideKey: return SvcWrap_SignalProcessWideKey64From32(system, args);
    case SvcId::GetSystemTick: return SvcWrap_GetSystemTick64From32(system, args);
    case SvcId::ConnectToNamedPort: return SvcWrap_ConnectToNamedPort64From32(system, args);
    case SvcId::SendSyncRequestLight: return SvcWrap_SendSyncRequestLight64From32(system, args);
    case SvcId::SendSyncRequest: return SvcWrap_SendSyncRequest64From32(system, args);
    case SvcId::SendSyncRequestWithUserBuffer: return SvcWrap_SendSyncRequestWithUserBuffer64From32(system, args);
    case SvcId::SendAsyncRequestWithUserBuffer: return SvcWrap_SendAsyncRequestWithUserBuffer64From32(system, args);
    case SvcId::GetProcessId: return SvcWrap_GetProcessId64From32(system, args);
    case SvcId::GetThreadId: return SvcWrap_GetThreadId64From32(system, args);
    case SvcId::Break: return SvcWrap_Break64From32(system, args);
    case SvcId::OutputDebugString: return SvcWrap_OutputDebugString64From32(system, args);
    case SvcId::ReturnFromException: return SvcWrap_ReturnFromException64From32(system, args);
    case SvcId::GetInfo: return SvcWrap_GetInfo64From32(system, args);
    case SvcId::FlushEntireDataCache: return SvcWrap_FlushEntireDataCache64From32(system, args);
    case SvcId::FlushDataCache: return SvcWrap_FlushDataCache64From32(system, args);
    case SvcId::MapPhysicalMemory: return SvcWrap_MapPhysicalMemory64From32(system, args);
    case SvcId::UnmapPhysicalMemory: return SvcWrap_UnmapPhysicalMemory64From32(system, args);
    case SvcId::GetDebugFutureThreadInfo: return SvcWrap_GetDebugFutureThreadInfo64From32(system, args);
    case SvcId::GetLastThreadInfo: return SvcWrap_GetLastThreadInfo64From32(system, args);
    case SvcId::GetResourceLimitLimitValue: return SvcWrap_GetResourceLimitLimitValue64From32(system, args);
    case SvcId::GetResourceLimitCurrentValue: return SvcWrap_GetResourceLimitCurrentValue64From32(system, args);
    case SvcId::SetThreadActivity: return SvcWrap_SetThreadActivity64From32(system, args);
    case SvcId::GetThreadContext3: return SvcWrap_GetThreadContext364From32(system, args);
    case SvcId::WaitForAddress: return SvcWrap_WaitForAddress64From32(system, args);
    case SvcId::SignalToAddress: return SvcWrap_SignalToAddress64From32(system, args);
    case SvcId::SynchronizePreemptionState: return SvcWrap_SynchronizePreemptionState64From32(system, args);
    case SvcId::GetResourceLimitPeakValue: return SvcWrap_GetResourceLimitPeakValue64From32(system, args);
    case SvcId::CreateIoPool: return SvcWrap_CreateIoPool64From32(system, args);
    case SvcId::CreateIoRegion: return SvcWrap_CreateIoRegion64From32(system, args);
    case SvcId::KernelDebug: return SvcWrap_KernelDebug64From32(system, args);
    case SvcId::ChangeKernelTraceState: return SvcWrap_ChangeKernelTraceState64From32(system, args);
    case SvcId::CreateSession: return SvcWrap_CreateSession64From32(system, args);
    case SvcId::AcceptSession: return SvcWrap_AcceptSession64From32(system, args);
    case SvcId::ReplyAndReceiveLight: return SvcWrap_ReplyAndReceiveLight64From32(system, args);
    case SvcId::ReplyAndReceive: return SvcWrap_ReplyAndReceive64From32(system, args);
    case SvcId::ReplyAndReceiveWithUserBuffer: return SvcWrap_ReplyAndReceiveWithUserBuffer64From32(system, args);
    case SvcId::CreateEvent: return SvcWrap_CreateEvent64From32(system, args);
    case SvcId::MapIoRegion: return SvcWrap_MapIoRegion64From32(system, args);
    case SvcId::UnmapIoRegion: return SvcWrap_UnmapIoRegion64From32(system, args);
    case SvcId::MapPhysicalMemoryUnsafe: return SvcWrap_MapPhysicalMemoryUnsafe64From32(system, args);
    case SvcId::UnmapPhysicalMemoryUnsafe: return SvcWrap_UnmapPhysicalMemoryUnsafe64From32(system, args);
    case SvcId::SetUnsafeLimit: return SvcWrap_SetUnsafeLimit64From32(system, args);
    case SvcId::CreateCodeMemory: return SvcWrap_CreateCodeMemory64From32(system, args);
    case SvcId::ControlCodeMemory: return SvcWrap_ControlCodeMemory64From32(system, args);
    case SvcId::SleepSystem: return SvcWrap_SleepSystem64From32(system, args);
    case SvcId::ReadWriteRegister: return SvcWrap_ReadWriteRegister64From32(system, args);
    case SvcId::SetProcessActivity: return SvcWrap_SetProcessActivity64From32(system, args);
    case SvcId::CreateSharedMemory: return SvcWrap_CreateSharedMemory64From32(system, args);
    case SvcId::MapTransferMemory: return SvcWrap_MapTransferMemory64From32(system, args);
    case SvcId::UnmapTransferMemory: return SvcWrap_UnmapTransferMemory64From32(system, args);
    case SvcId::CreateInterruptEvent: return SvcWrap_CreateInterruptEvent64From32(system, args);
    case SvcId::QueryPhysicalAddress: return SvcWrap_QueryPhysicalAddress64From32(system, args);
    case SvcId::QueryIoMapping: return SvcWrap_QueryIoMapping64From32(system, args);
    case SvcId::CreateDeviceAddressSpace: return SvcWrap_CreateDeviceAddressSpace64From32(system, args);
    case SvcId::AttachDeviceAddressSpace: return SvcWrap_AttachDeviceAddressSpace64From32(system, args);
    case SvcId::DetachDeviceAddressSpace: return SvcWrap_DetachDeviceAddressSpace64From32(system, args);
    case SvcId::MapDeviceAddressSpaceByForce: return SvcWrap_MapDeviceAddressSpaceByForce64From32(system, args);
    case SvcId::MapDeviceAddressSpaceAligned: return SvcWrap_MapDeviceAddressSpaceAligned64From32(system, args);
    case SvcId::UnmapDeviceAddressSpace: return SvcWrap_UnmapDeviceAddressSpace64From32(system, args);
    case SvcId::InvalidateProcessDataCache: return SvcWrap_InvalidateProcessDataCache64From32(system, args);
    case SvcId::StoreProcessDataCache: return SvcWrap_StoreProcessDataCache64From32(system, args);
    case SvcId::FlushProcessDataCache: return SvcWrap_FlushProcessDataCache64From32(system, args);
    case SvcId::DebugActiveProcess: return SvcWrap_DebugActiveProcess64From32(system, args);
    case SvcId::BreakDebugProcess: return SvcWrap_BreakDebugProcess64From32(system, args);
    case SvcId::TerminateDebugProcess: return SvcWrap_TerminateDebugProcess64From32(system, args);
    case SvcId::GetDebugEvent: return SvcWrap_GetDebugEvent64From32(system, args);
    case SvcId::ContinueDebugEvent: return SvcWrap_ContinueDebugEvent64From32(system, args);
    case SvcId::GetProcessList: return SvcWrap_GetProcessList64From32(system, args);
    case SvcId::GetThreadList: return SvcWrap_GetThreadList64From32(system, args);
    case SvcId::GetDebugThreadContext: return SvcWrap_GetDebugThreadContext64From32(system, args);
    case SvcId::SetDebugThreadContext: return SvcWrap_SetDebugThreadContext64From32(system, args);
    case SvcId::QueryDebugProcessMemory: return SvcWrap_QueryDebugProcessMemory64From32(system, args);
    case SvcId::ReadDebugProcessMemory: return SvcWrap_ReadDebugProcessMemory64From32(system, args);
    case SvcId::WriteDebugProcessMemory: return SvcWrap_WriteDebugProcessMemory64From32(system, args);
    case SvcId::SetHardwareBreakPoint: return SvcWrap_SetHardwareBreakPoint64From32(system, args);
    case SvcId::GetDebugThreadParam: return SvcWrap_GetDebugThreadParam64From32(system, args);
    case SvcId::GetSystemInfo: return SvcWrap_GetSystemInfo64From32(system, args);
    case SvcId::CreatePort: return SvcWrap_CreatePort64From32(system, args);
    case SvcId::ManageNamedPort: return SvcWrap_ManageNamedPort64From32(system, args);
    case SvcId::ConnectToPort: return SvcWrap_ConnectToPort64From32(system, args);
    case SvcId::SetProcessMemoryPermission: return SvcWrap_SetProcessMemoryPermission64From32(system, args);
    case SvcId::MapProcessMemory: return SvcWrap_MapProcessMemory64From32(system, args);
    case SvcId::UnmapProcessMemory: return SvcWrap_UnmapProcessMemory64From32(system, args);
    case SvcId::QueryProcessMemory: return SvcWrap_QueryProcessMemory64From32(system, args);
    case SvcId::MapProcessCodeMemory: return SvcWrap_MapProcessCodeMemory64From32(system, args);
    case SvcId::UnmapProcessCodeMemory: return SvcWrap_UnmapProcessCodeMemory64From32(system, args);
    case SvcId::CreateProcess: return SvcWrap_CreateProcess64From32(system, args);
    case SvcId::StartProcess: return SvcWrap_StartProcess64From32(system, args);
    case SvcId::TerminateProcess: return SvcWrap_TerminateProcess64From32(system, args);
    case SvcId::GetProcessInfo: return SvcWrap_GetProcessInfo64From32(system, args);
    case SvcId::CreateResourceLimit: return SvcWrap_CreateResourceLimit64From32(system, args);
    case SvcId::SetResourceLimitLimitValue: return SvcWrap_SetResourceLimitLimitValue64From32(system, args);
    case SvcId::CallSecureMonitor: return SvcWrap_CallSecureMonitor64From32(system, args);
    case SvcId::MapInsecureMemory: return SvcWrap_MapInsecureMemory64From32(system, args);
    case SvcId::UnmapInsecureMemory: return SvcWrap_UnmapInsecureMemory64From32(system, args);
    default:
        LOG_CRITICAL(Kernel_SVC, "Unknown SVC {:x}!", imm);
        break;
    }
}

static void Call64(Core::System& system, u32 imm, std::span<uint64_t, 8> args) {
    switch (SvcId(imm)) {
    case SvcId::SetHeapSize: return SvcWrap_SetHeapSize64(system, args);
    case SvcId::SetMemoryPermission: return SvcWrap_SetMemoryPermission64(system, args);
    case SvcId::SetMemoryAttribute: return SvcWrap_SetMemoryAttribute64(system, args);
    case SvcId::MapMemory: return SvcWrap_MapMemory64(system, args);
    case SvcId::UnmapMemory: return SvcWrap_UnmapMemory64(system, args);
    case SvcId::QueryMemory: return SvcWrap_QueryMemory64(system, args);
    case SvcId::ExitProcess: return SvcWrap_ExitProcess64(system, args);
    case SvcId::CreateThread: return SvcWrap_CreateThread64(system, args);
    case SvcId::StartThread: return SvcWrap_StartThread64(system, args);
    case SvcId::ExitThread: return SvcWrap_ExitThread64(system, args);
    case SvcId::SleepThread: return SvcWrap_SleepThread64(system, args);
    case SvcId::GetThreadPriority: return SvcWrap_GetThreadPriority64(system, args);
    case SvcId::SetThreadPriority: return SvcWrap_SetThreadPriority64(system, args);
    case SvcId::GetThreadCoreMask: return SvcWrap_GetThreadCoreMask64(system, args);
    case SvcId::SetThreadCoreMask: return SvcWrap_SetThreadCoreMask64(system, args);
    case SvcId::GetCurrentProcessorNumber: return SvcWrap_GetCurrentProcessorNumber64(system, args);
    case SvcId::SignalEvent: return SvcWrap_SignalEvent64(system, args);
    case SvcId::ClearEvent: return SvcWrap_ClearEvent64(system, args);
    case SvcId::MapSharedMemory: return SvcWrap_MapSharedMemory64(system, args);
    case SvcId::UnmapSharedMemory: return SvcWrap_UnmapSharedMemory64(system, args);
    case SvcId::CreateTransferMemory: return SvcWrap_CreateTransferMemory64(system, args);
    case SvcId::CloseHandle: return SvcWrap_CloseHandle64(system, args);
    case SvcId::ResetSignal: return SvcWrap_ResetSignal64(system, args);
    case SvcId::WaitSynchronization: return SvcWrap_WaitSynchronization64(system, args);
    case SvcId::CancelSynchronization: return SvcWrap_CancelSynchronization64(system, args);
    case SvcId::ArbitrateLock: return SvcWrap_ArbitrateLock64(system, args);
    case SvcId::ArbitrateUnlock: return SvcWrap_ArbitrateUnlock64(system, args);
    case SvcId::WaitProcessWideKeyAtomic: return SvcWrap_WaitProcessWideKeyAtomic64(system, args);
    case SvcId::SignalProcessWideKey: return SvcWrap_SignalProcessWideKey64(system, args);
    case SvcId::GetSystemTick: return SvcWrap_GetSystemTick64(system, args);
    case SvcId::ConnectToNamedPort: return SvcWrap_ConnectToNamedPort64(system, args);
    case SvcId::SendSyncRequestLight: return SvcWrap_SendSyncRequestLight64(system, args);
    case SvcId::SendSyncRequest: return SvcWrap_SendSyncRequest64(system, args);
    case SvcId::SendSyncRequestWithUserBuffer: return SvcWrap_SendSyncRequestWithUserBuffer64(system, args);
    case SvcId::SendAsyncRequestWithUserBuffer: return SvcWrap_SendAsyncRequestWithUserBuffer64(system, args);
    case SvcId::GetProcessId: return SvcWrap_GetProcessId64(system, args);
    case SvcId::GetThreadId: return SvcWrap_GetThreadId64(system, args);
    case SvcId::Break: return SvcWrap_Break64(system, args);
    case SvcId::OutputDebugString: return SvcWrap_OutputDebugString64(system, args);
    case SvcId::ReturnFromException: return SvcWrap_ReturnFromException64(system, args);
    case SvcId::GetInfo: return SvcWrap_GetInfo64(system, args);
    case SvcId::FlushEntireDataCache: return SvcWrap_FlushEntireDataCache64(system, args);
    case SvcId::FlushDataCache: return SvcWrap_FlushDataCache64(system, args);
    case SvcId::MapPhysicalMemory: return SvcWrap_MapPhysicalMemory64(system, args);
    case SvcId::UnmapPhysicalMemory: return SvcWrap_UnmapPhysicalMemory64(system, args);
    case SvcId::GetDebugFutureThreadInfo: return SvcWrap_GetDebugFutureThreadInfo64(system, args);
    case SvcId::GetLastThreadInfo: return SvcWrap_GetLastThreadInfo64(system, args);
    case SvcId::GetResourceLimitLimitValue: return SvcWrap_GetResourceLimitLimitValue64(system, args);
    case SvcId::GetResourceLimitCurrentValue: return SvcWrap_GetResourceLimitCurrentValue64(system, args);
    case SvcId::SetThreadActivity: return SvcWrap_SetThreadActivity64(system, args);
    case SvcId::GetThreadContext3: return SvcWrap_GetThreadContext364(system, args);
    case SvcId::WaitForAddress: return SvcWrap_WaitForAddress64(system, args);
    case SvcId::SignalToAddress: return SvcWrap_SignalToAddress64(system, args);
    case SvcId::SynchronizePreemptionState: return SvcWrap_SynchronizePreemptionState64(system, args);
    case SvcId::GetResourceLimitPeakValue: return SvcWrap_GetResourceLimitPeakValue64(system, args);
    case SvcId::CreateIoPool: return SvcWrap_CreateIoPool64(system, args);
    case SvcId::CreateIoRegion: return SvcWrap_CreateIoRegion64(system, args);
    case SvcId::KernelDebug: return SvcWrap_KernelDebug64(system, args);
    case SvcId::ChangeKernelTraceState: return SvcWrap_ChangeKernelTraceState64(system, args);
    case SvcId::CreateSession: return SvcWrap_CreateSession64(system, args);
    case SvcId::AcceptSession: return SvcWrap_AcceptSession64(system, args);
    case SvcId::ReplyAndReceiveLight: return SvcWrap_ReplyAndReceiveLight64(system, args);
    case SvcId::ReplyAndReceive: return SvcWrap_ReplyAndReceive64(system, args);
    case SvcId::ReplyAndReceiveWithUserBuffer: return SvcWrap_ReplyAndReceiveWithUserBuffer64(system, args);
    case SvcId::CreateEvent: return SvcWrap_CreateEvent64(system, args);
    case SvcId::MapIoRegion: return SvcWrap_MapIoRegion64(system, args);
    case SvcId::UnmapIoRegion: return SvcWrap_UnmapIoRegion64(system, args);
    case SvcId::MapPhysicalMemoryUnsafe: return SvcWrap_MapPhysicalMemoryUnsafe64(system, args);
    case SvcId::UnmapPhysicalMemoryUnsafe: return SvcWrap_UnmapPhysicalMemoryUnsafe64(system, args);
    case SvcId::SetUnsafeLimit: return SvcWrap_SetUnsafeLimit64(system, args);
    case SvcId::CreateCodeMemory: return SvcWrap_CreateCodeMemory64(system, args);
    case SvcId::ControlCodeMemory: return SvcWrap_ControlCodeMemory64(system, args);
    case SvcId::SleepSystem: return SvcWrap_SleepSystem64(system, args);
    case SvcId::ReadWriteRegister: return SvcWrap_ReadWriteRegister64(system, args);
    case SvcId::SetProcessActivity: return SvcWrap_SetProcessActivity64(system, args);
    case SvcId::CreateSharedMemory: return SvcWrap_CreateSharedMemory64(system, args);
    case SvcId::MapTransferMemory: return SvcWrap_MapTransferMemory64(system, args);
    case SvcId::UnmapTransferMemory: return SvcWrap_UnmapTransferMemory64(system, args);
    case SvcId::CreateInterruptEvent: return SvcWrap_CreateInterruptEvent64(system, args);
    case SvcId::QueryPhysicalAddress: return SvcWrap_QueryPhysicalAddress64(system, args);
    case SvcId::QueryIoMapping: return SvcWrap_QueryIoMapping64(system, args);
    case SvcId::CreateDeviceAddressSpace: return SvcWrap_CreateDeviceAddressSpace64(system, args);
    case SvcId::AttachDeviceAddressSpace: return SvcWrap_AttachDeviceAddressSpace64(system, args);
    case SvcId::DetachDeviceAddressSpace: return SvcWrap_DetachDeviceAddressSpace64(system, args);
    case SvcId::MapDeviceAddressSpaceByForce: return SvcWrap_MapDeviceAddressSpaceByForce64(system, args);
    case SvcId::MapDeviceAddressSpaceAligned: return SvcWrap_MapDeviceAddressSpaceAligned64(system, args);
    case SvcId::UnmapDeviceAddressSpace: return SvcWrap_UnmapDeviceAddressSpace64(system, args);
    case SvcId::InvalidateProcessDataCache: return SvcWrap_InvalidateProcessDataCache64(system, args);
    case SvcId::StoreProcessDataCache: return SvcWrap_StoreProcessDataCache64(system, args);
    case SvcId::FlushProcessDataCache: return SvcWrap_FlushProcessDataCache64(system, args);
    case SvcId::DebugActiveProcess: return SvcWrap_DebugActiveProcess64(system, args);
    case SvcId::BreakDebugProcess: return SvcWrap_BreakDebugProcess64(system, args);
    case SvcId::TerminateDebugProcess: return SvcWrap_TerminateDebugProcess64(system, args);
    case SvcId::GetDebugEvent: return SvcWrap_GetDebugEvent64(system, args);
    case SvcId::ContinueDebugEvent: return SvcWrap_ContinueDebugEvent64(system, args);
    case SvcId::GetProcessList: return SvcWrap_GetProcessList64(system, args);
    case SvcId::GetThreadList: return SvcWrap_GetThreadList64(system, args);
    case SvcId::GetDebugThreadContext: return SvcWrap_GetDebugThreadContext64(system, args);
    case SvcId::SetDebugThreadContext: return SvcWrap_SetDebugThreadContext64(system, args);
    case SvcId::QueryDebugProcessMemory: return SvcWrap_QueryDebugProcessMemory64(system, args);
    case SvcId::ReadDebugProcessMemory: return SvcWrap_ReadDebugProcessMemory64(system, args);
    case SvcId::WriteDebugProcessMemory: return SvcWrap_WriteDebugProcessMemory64(system, args);
    case SvcId::SetHardwareBreakPoint: return SvcWrap_SetHardwareBreakPoint64(system, args);
    case SvcId::GetDebugThreadParam: return SvcWrap_GetDebugThreadParam64(system, args);
    case SvcId::GetSystemInfo: return SvcWrap_GetSystemInfo64(system, args);
    case SvcId::CreatePort: return SvcWrap_CreatePort64(system, args);
    case SvcId::ManageNamedPort: return SvcWrap_ManageNamedPort64(system, args);
    case SvcId::ConnectToPort: return SvcWrap_ConnectToPort64(system, args);
    case SvcId::SetProcessMemoryPermission: return SvcWrap_SetProcessMemoryPermission64(system, args);
    case SvcId::MapProcessMemory: return SvcWrap_MapProcessMemory64(system, args);
    case SvcId::UnmapProcessMemory: return SvcWrap_UnmapProcessMemory64(system, args);
    case SvcId::QueryProcessMemory: return SvcWrap_QueryProcessMemory64(system, args);
    case SvcId::MapProcessCodeMemory: return SvcWrap_MapProcessCodeMemory64(system, args);
    case SvcId::UnmapProcessCodeMemory: return SvcWrap_UnmapProcessCodeMemory64(system, args);
    case SvcId::CreateProcess: return SvcWrap_CreateProcess64(system, args);
    case SvcId::StartProcess: return SvcWrap_StartProcess64(system, args);
    case SvcId::TerminateProcess: return SvcWrap_TerminateProcess64(system, args);
    case SvcId::GetProcessInfo: return SvcWrap_GetProcessInfo64(system, args);
    case SvcId::CreateResourceLimit: return SvcWrap_CreateResourceLimit64(system, args);
    case SvcId::SetResourceLimitLimitValue: return SvcWrap_SetResourceLimitLimitValue64(system, args);
    case SvcId::CallSecureMonitor: return SvcWrap_CallSecureMonitor64(system, args);
    case SvcId::MapInsecureMemory: return SvcWrap_MapInsecureMemory64(system, args);
    case SvcId::UnmapInsecureMemory: return SvcWrap_UnmapInsecureMemory64(system, args);
    default:
        LOG_CRITICAL(Kernel_SVC, "Unknown SVC {:x}!", imm);
        break;
    }
}
void Call(Core::System& system, u32 imm) {
    auto& kernel = system.Kernel();
    auto& process = GetCurrentProcess(kernel);
    std::array<uint64_t, 8> args;
    kernel.CurrentPhysicalCore().SaveSvcArguments(process, args);
    LOG_TRACE(Kernel_SVC, "{} [0]={:#x} [1]={:#x} [2]={:#x} [3]={:#x} [4]={:#x} [5]={:#x} [6]={:#x}",
        imm, GetArg32(args, 0), GetArg32(args, 1), GetArg32(args, 2),
        GetArg32(args, 3), GetArg32(args, 4), GetArg32(args, 5), GetArg32(args, 6));
    //kernel.EnterSVCProfile();
    if (process.Is64Bit())
        Call64(system, imm, args);
    else
        Call32(system, imm, args);
    //kernel.ExitSVCProfile();
    kernel.CurrentPhysicalCore().LoadSvcArguments(process, args);
}

} // namespace Kernel::Svc
