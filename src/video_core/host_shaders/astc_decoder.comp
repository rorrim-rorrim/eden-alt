// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project
// SPDX-License-Identifier: GPL-2.0-or-later

#version 450

#ifdef VULKAN

#define BEGIN_PUSH_CONSTANTS layout(push_constant) uniform PushConstants {
#define END_PUSH_CONSTANTS };
#define UNIFORM(n)
#define BINDING_INPUT_BUFFER 0
#define BINDING_OUTPUT_IMAGE 1

#else // ^^^ Vulkan ^^^ // vvv OpenGL vvv

#define BEGIN_PUSH_CONSTANTS
#define END_PUSH_CONSTANTS
#define UNIFORM(n) layout(location = n) uniform
#define BINDING_INPUT_BUFFER 0
#define BINDING_OUTPUT_IMAGE 0

#endif

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

BEGIN_PUSH_CONSTANTS
UNIFORM(1) uvec2 block_dims;
UNIFORM(2) uint layer_stride;
UNIFORM(3) uint block_size;
UNIFORM(4) uint x_shift;
UNIFORM(5) uint block_height;
UNIFORM(6) uint block_height_mask;
END_PUSH_CONSTANTS

struct EncodingData {
    uint data;
};

layout(binding = BINDING_INPUT_BUFFER, std430) readonly restrict buffer InputBufferU32 {
    uvec4 astc_data[];
};

layout(binding = BINDING_OUTPUT_IMAGE, rgba8) uniform writeonly restrict image2DArray dest_image;

const uint GOB_SIZE_X_SHIFT = 6;
const uint GOB_SIZE_Y_SHIFT = 3;
const uint GOB_SIZE_SHIFT = GOB_SIZE_X_SHIFT + GOB_SIZE_Y_SHIFT;

const uint BYTES_PER_BLOCK_LOG2 = 4;

// DO NOT CHANGE - code depends on the value of these!
const uint JUST_BITS = 0u;
const uint QUINT = 1u;
const uint TRIT = 2u;

// ASTC Encodings data, sorted in ascending order based on their BitLength value
// (see GetBitLength() function)
const uint encoding_values[22] = uint[](
    (JUST_BITS),
    (JUST_BITS | (1u << 8u)),
    (TRIT),
    (JUST_BITS | (2u << 8u)),
    (QUINT),
    (TRIT | (1u << 8u)),
    (JUST_BITS | (3u << 8u)),
    (QUINT | (1u << 8u)),
    (TRIT | (2u << 8u)),
    (JUST_BITS | (4u << 8u)),
    (QUINT | (2u << 8u)),
    (TRIT | (3u << 8u)),
    (JUST_BITS | (5u << 8u)),
    (QUINT | (3u << 8u)),
    (TRIT | (4u << 8u)),
    (JUST_BITS | (6u << 8u)),
    (QUINT | (4u << 8u)),
    (TRIT | (5u << 8u)),
    (JUST_BITS | (7u << 8u)),
    (QUINT | (5u << 8u)),
    (TRIT | (6u << 8u)),
    (JUST_BITS | (8u << 8u))
);

// Input ASTC texture globals
uint total_bitsread = 0;
// Color data globals
uvec4 color_endpoint_data;
uint color_bitsread = 0;

// Global "vector" to be pushed into when decoding
// At most will require BLOCK_WIDTH x BLOCK_HEIGHT in single plane mode
// At most will require BLOCK_WIDTH x BLOCK_HEIGHT x 2 in dual plane mode
// So the maximum would be 144 (12 x 12) elements, x 2 for two planes
#define DIVCEIL(number, divisor) (number + divisor - 1) / divisor
#define ARRAY_NUM_ELEMENTS 144
#define VECTOR_ARRAY_SIZE DIVCEIL(ARRAY_NUM_ELEMENTS * 2, 4)
uint result_vector[ARRAY_NUM_ELEMENTS * 2];

int result_index = 0;
uint result_vector_max_index;

// EncodingData helpers
uint Encoding(EncodingData val) {
    return bitfieldExtract(val.data, 0, 8);
}
uint NumBits(EncodingData val) {
    return bitfieldExtract(val.data, 8, 8);
}
uint BitValue(EncodingData val) {
    return bitfieldExtract(val.data, 16, 8);
}
uint QuintTritValue(EncodingData val) {
    return bitfieldExtract(val.data, 24, 8);
}

void Encoding(inout EncodingData val, uint v) {
    val.data = bitfieldInsert(val.data, v, 0, 8);
}
void NumBits(inout EncodingData val, uint v) {
    val.data = bitfieldInsert(val.data, v, 8, 8);
}
void BitValue(inout EncodingData val, uint v) {
    val.data = bitfieldInsert(val.data, v, 16, 8);
}
void QuintTritValue(inout EncodingData val, uint v) {
    val.data = bitfieldInsert(val.data, v, 24, 8);
}

EncodingData CreateEncodingData(uint encoding, uint num_bits, uint bit_val, uint quint_trit_val) {
    return EncodingData(((encoding) << 0u) | ((num_bits) << 8u) |
                        ((bit_val) << 16u) | ((quint_trit_val) << 24u));
}


void ResultEmplaceBack(EncodingData val) {
    // A = result_index, B = result_vector_max_index
    // A >= B -> A - B >= 0
    // A <  B -> A - B <  0
    result_vector[min(32U, result_index)] = val.data; // 0 if not set
    ++result_index;
}

uvec4 ReplicateByteTo16(uvec4 value) {
    return value * 0x101;
}

uint ReplicateBitTo7(uint value) {
    return value * 127;
}

uint ReplicateBitTo9(uint value) {
    return value * 511;
}

const uint mod6_table = 0
    | ((6 % 1) << (2 * 1)) | ((6 % 2) << (2 * 2))
    | ((6 % 3) << (2 * 3)) | ((6 % 4) << (2 * 4))
    | ((6 % 5) << (2 * 5)) | ((6 % 6) << (2 * 6));
const uint mod8_table = 0
    | ((8 % 1) << (2 * 1)) | ((8 % 2) << (2 * 2))
    | ((8 % 3) << (2 * 3)) | ((8 % 4) << (2 * 4))
    | ((8 % 5) << (2 * 5)) | ((8 % 6) << (2 * 6))
    | ((8 % 7) << (2 * 7)) | ((8 % 8) << (2 * 8));
// Assumes num_bits < to_bit, num_bits and to_bit != 0
uint ReplicateBits(uint value, uint num_bits, uint to_bit, uint table) {
    const uint repl = value & ((1 << num_bits) - 1);
    const uint shift = (table >> (num_bits << 1)) & 3;
    uint v = repl;
    v |= v << (num_bits << 0); // [ xxxx xxrr ]
    v |= v << (num_bits << 1); // [ xxxx rrrr ]
    v |= v << (num_bits << 2); // [ rrrr rrrr ]
    v = (v << shift) | repl >> (num_bits - shift);
    return v & ((1 << to_bit) - 1);
}
uint FastReplicateTo8(uint value, uint num_bits) {
    return ReplicateBits(value, num_bits, 8, mod8_table);
}
uint FastReplicateTo6(uint value, uint num_bits) {
    return ReplicateBits(value, num_bits, 6, mod6_table);
}

uint Hash52(uint p) {
    p ^= p >> 15;
    p -= p << 17;
    p += p << 7;
    p += p << 4;
    p ^= p >> 5;
    p += p << 16;
    p ^= p >> 7;
    p ^= p >> 3;
    p ^= p << 6;
    p ^= p >> 17;
    return p;
}

uint Select2DPartition(uint seed, uvec2 pos, uint partition_count) {
    pos <<= uint(block_dims.y * block_dims.x < 32);
    seed += (partition_count - 1) * 1024;
    const uint rnum = Hash52(uint(seed));
    uvec2 shift = uvec2(
        (seed & 2) > 0 ? 4 : 5,
        (partition_count == 3) ? 6 : 5
    );
    shift.xy = (seed & 1) > 0 ? shift.xy : shift.yx;
    uvec4 rseed[2] = uvec4[](
        (uvec4(rnum) >> uvec4(0, 4, 8, 12)) & 0xf,
        (uvec4(rnum) >> uvec4(16, 20, 24, 28)) & 0xf
    );
    rseed[0] = (rseed[0] * rseed[0]) >> shift.xyxy;
    rseed[1] = (rseed[1] * rseed[1]) >> shift.xyxy;
    const uvec4 rnum_vec = uvec4(rnum) >> uvec4(14, 10, 6, 2);
    const uvec4 result_mask = ((uvec4(0, 1, 2, 3) - partition_count) >> 8) & 0x3f;
    uvec4 result = uvec4(
        rseed[0].xz * pos.xx + rseed[0].yw * pos.yy + rnum_vec.xy,
        rseed[1].xz * pos.xx + rseed[1].yw * pos.yy + rnum_vec.zw
    ) & result_mask;
    if (result.x >= result.y && result.x >= result.z && result.x >= result.w) {
        return 0;
    } else if (result.y >= result.z && result.y >= result.w) {
        return 1;
    } else if (result.z >= result.w) {
        return 2;
    } else {
        return 3;
    }
}

uint ExtractBits(uvec4 payload, uint offset, uint bits) {
    if (bits == 0 || bits > 32)
        return 0;
    const uint last_offset = offset + bits - 1;
    const uint shifted_offset = offset >> 5;
    if ((last_offset >> 5) == shifted_offset)
        return bitfieldExtract(payload[shifted_offset], int(offset & 31), int(bits));
    const uint first_bits = 32 - (offset & 31);
    const uvec4 next = uvec4(payload.yzw, 0);
    return bitfieldExtract(payload[shifted_offset], int(offset & 31), int(first_bits))
        | (bitfieldExtract(next[shifted_offset], 0, int(bits - first_bits)) << first_bits);
}

uint StreamBits(uvec4 local_buff, uint num_bits) {
    const uint ret = ExtractBits(local_buff, total_bitsread, num_bits);
    total_bitsread += num_bits;
    return ret;
}

void SkipBits(uint num_bits) {
    total_bitsread += num_bits;
}

uint StreamColorBits(uint num_bits) {
    const uint ret = ExtractBits(color_endpoint_data, color_bitsread, num_bits);
    color_bitsread += num_bits;
    return ret;
}

// Returns the number of bits required to encode n_vals values.
uint GetBitLength(uint n_vals, uint encoding_index) {
    // uint Div3Floor(uint v) { return (v * 0x5556) >> 16; }
    // uint Div3Ceil(uint v) { return Div3Floor(v + 2); }
    // uint Div5Floor(uint v) { return (v * 0x3334) >> 16; }
    // uint Div5Ceil(uint v) { return Div5Floor(v + 4); }
    const EncodingData encoding_value = EncodingData(encoding_values[encoding_index]);
    const uint encoding = Encoding(encoding_value);
    const uint num_bits = NumBits(encoding_value);
    const uvec3 div_constant = uvec3(0, 0x5556, 0x3334);
    return num_bits * n_vals
        + ((((n_vals * ((0x870 >> (encoding << 2)) & 0xf)) + ((0x420 >> (encoding << 2)) & 0xf))
        * div_constant[encoding]) >> 16);
}

uint GetNumWeightValues(uvec2 size, bool dual_plane) {
    return (size.x * size.y) << uint(dual_plane);
}

uint GetPackedBitSize(uvec2 size, bool dual_plane, uint max_weight) {
    const uint n_vals = GetNumWeightValues(size, dual_plane);
    return GetBitLength(n_vals, max_weight);
}

uint BitsBracket(uint bits, uint pos) {
    return ((bits >> pos) & 1);
}

uint BitsOp(uint bits, uint start, uint end) {
    const uint mask = (1 << (end - start + 1)) - 1;
    return ((bits >> start) & mask);
}

void DecodeQuintBlock(uint num_bits) {
    uvec3 m;
    uvec4 qQ;
    m[0] = StreamColorBits(num_bits);
    qQ.w = StreamColorBits(3);
    m[1] = StreamColorBits(num_bits);
    qQ.w |= StreamColorBits(2) << 3;
    m[2] = StreamColorBits(num_bits);
    qQ.w |= StreamColorBits(2) << 5;
    if (BitsOp(qQ.w, 1, 2) == 3 && BitsOp(qQ.w, 5, 6) == 0) {
        qQ.x = 4;
        qQ.y = 4;
        qQ.z = (BitsBracket(qQ.w, 0) << 2)
            | ((BitsBracket(qQ.w, 4) & ~BitsBracket(qQ.w, 0)) << 1)
            | (BitsBracket(qQ.w, 3) & ~BitsBracket(qQ.w, 0));
    } else {
        uint C = 0;
        if (BitsOp(qQ.w, 1, 2) == 3) {
            qQ.z = 4;
            C = (BitsOp(qQ.w, 3, 4) << 3)
                | ((~BitsOp(qQ.w, 5, 6) & 3) << 1)
                | BitsBracket(qQ.w, 0);
        } else {
            qQ.z = BitsOp(qQ.w, 5, 6);
            C = BitsOp(qQ.w, 0, 4);
        }
        if (BitsOp(C, 0, 2) == 5) {
            qQ.y = 4;
            qQ.x = BitsOp(C, 3, 4);
        } else {
            qQ.y = BitsOp(C, 3, 4);
            qQ.x = BitsOp(C, 0, 2);
        }
    }
    for (uint i = 0; i < 3; i++)
        ResultEmplaceBack(CreateEncodingData(QUINT, num_bits, m[i], qQ[i]));
}

void DecodeTritBlock(uint num_bits) {
    uvec4 m;
    uvec4 t;
    uvec3 tm5t5;
    m[0] = StreamColorBits(num_bits);
    tm5t5.x = StreamColorBits(2);
    m[1] = StreamColorBits(num_bits);
    tm5t5.x |= StreamColorBits(2) << 2;
    m[2] = StreamColorBits(num_bits);
    tm5t5.x |= StreamColorBits(1) << 4;
    m[3] = StreamColorBits(num_bits);
    tm5t5.x |= StreamColorBits(2) << 5;
    tm5t5.y = StreamColorBits(num_bits);
    tm5t5.x |= StreamColorBits(1) << 7;
    uint C = 0;
    if (BitsOp(tm5t5.x, 2, 4) == 7) {
        C = (BitsOp(tm5t5.x, 5, 7) << 2) | BitsOp(tm5t5.x, 0, 1);
        tm5t5.z = 2;
        t[3] = 2;
    } else {
        C = BitsOp(tm5t5.x, 0, 4);
        if (BitsOp(tm5t5.x, 5, 6) == 3) {
            tm5t5.z = 2;
            t[3] = BitsBracket(tm5t5.x, 7);
        } else {
            tm5t5.z = BitsBracket(tm5t5.x, 7);
            t[3] = BitsOp(tm5t5.x, 5, 6);
        }
    }
    if (BitsOp(C, 0, 1) == 3) {
        t[2] = 2;
        t[1] = BitsBracket(C, 4);
        t[0] = (BitsBracket(C, 3) << 1) | (BitsBracket(C, 2) & ~BitsBracket(C, 3));
    } else if (BitsOp(C, 2, 3) == 3) {
        t[2] = 2;
        t[1] = 2;
        t[0] = BitsOp(C, 0, 1);
    } else {
        t[2] = BitsBracket(C, 4);
        t[1] = BitsOp(C, 2, 3);
        t[0] = (BitsBracket(C, 1) << 1) | (BitsBracket(C, 0) & ~BitsBracket(C, 1));
    }
    for (uint i = 0; i < 4; i++)
        ResultEmplaceBack(CreateEncodingData(TRIT, num_bits, m[i], t[i]));
    ResultEmplaceBack(CreateEncodingData(TRIT, num_bits, tm5t5.y, tm5t5.z));
}

void DecodeIntegerSequence(uint max_range, uint num_values) {
    EncodingData val = EncodingData(encoding_values[max_range]);
    const uint encoding = Encoding(val);
    const uint num_bits = NumBits(val);
    for (uint i = 0; i < num_values && result_index < result_vector_max_index; ) {
        switch (encoding) {
        case QUINT:
            DecodeQuintBlock(num_bits);
            i += 3;
            break;
        case TRIT:
            DecodeTritBlock(num_bits);
            i += 5;
            break;
        case JUST_BITS:
            BitValue(val, StreamColorBits(num_bits));
            ResultEmplaceBack(val);
            i++;
            break;
        }
    }
}

uint DecodeSingleColorValue(EncodingData val) {
    const uint encoding = Encoding(val);
    const uint bitlen = NumBits(val);
    const uint bitval = BitValue(val);
    uint B = 0, C = 0, D = 0;
    uint A = ReplicateBitTo9((bitval & 1));
    switch (encoding) {
    case JUST_BITS:
        break;
    case TRIT: {
        D = QuintTritValue(val);
        switch (bitlen) {
        case 1:
            C = 204;
            break;
        case 2: {
            C = 93;
            const uint b = (bitval >> 1) & 1;
            B = (b << 8) | (b << 4) | (b << 2) | (b << 1);
            break;
        }
        case 3: {
            C = 44;
            const uint cb = (bitval >> 1) & 3;
            B = (cb << 7) | (cb << 2) | cb;
            break;
        }
        case 4: {
            C = 22;
            const uint dcb = (bitval >> 1) & 7;
            B = (dcb << 6) | dcb;
            break;
        }
        case 5: {
            C = 11;
            const uint edcb = (bitval >> 1) & 0xF;
            B = (edcb << 5) | (edcb >> 2);
            break;
        }
        case 6: {
            C = 5;
            const uint fedcb = (bitval >> 1) & 0x1F;
            B = (fedcb << 4) | (fedcb >> 4);
            break;
        }
        }
        break;
    }
    case QUINT: {
        D = QuintTritValue(val);
        switch (bitlen) {
        case 1:
            C = 113;
            break;
        case 2: {
            C = 54;
            const uint b = (bitval >> 1) & 1;
            B = (b << 8) | (b << 3) | (b << 2);
            break;
        }
        case 3: {
            C = 26;
            const uint cb = (bitval >> 1) & 3;
            B = (cb << 7) | (cb << 1) | (cb >> 1);
            break;
        }
        case 4: {
            C = 13;
            const uint dcb = (bitval >> 1) & 7;
            B = (dcb << 6) | (dcb >> 1);
            break;
        }
        case 5: {
            C = 6;
            const uint edcb = (bitval >> 1) & 0xF;
            B = (edcb << 5) | (edcb >> 3);
            break;
        }
        }
        break;
    }
    }
    uint unq = D * C + B;
    unq = unq ^ A;
    unq = (A & 0x80) | (unq >> 2);
    return encoding == JUST_BITS ? FastReplicateTo8(bitval, bitlen) : unq;
}

void DecodeColorValues(uvec4 modes, uint num_partitions, uint color_data_bits, out uint color_values[32]) {
    // TODO: modes[] zero on invalid, so less ops
    const uvec4 num_values_tmp = (((modes >> 2) + 1) << 1) & ((uvec4(0, 1, 2, 3) - num_partitions) >> 8);
    uint num_values = num_values_tmp.x + num_values_tmp.y + num_values_tmp.z + num_values_tmp.w;
    // Find the largest encoding that's within color_data_bits
    // TODO(ameerj): profile with binary search
    uint range = 0;
    while (++range < encoding_values.length()) {
        const uint bit_length = GetBitLength(num_values, int(range));
        if (bit_length > color_data_bits) {
            break;
        }
    }
    const uint upper_bound = num_values;
    DecodeIntegerSequence(range - 1, num_values);
    for (int i = 0; i < upper_bound; ++i) {
        color_values[i + 1] = DecodeSingleColorValue(EncodingData(result_vector[i]));
    }
}

ivec2 BitTransferSigned(int a, int b) {
    ivec2 transferred = ivec2(
        (a >> 1) & 0x3F,
        (b >> 1) | (a & 0x80)
    );
    if ((transferred.x & 0x20) > 0) {
        transferred.x -= 0x40;
    }
    return transferred;
}

uvec4 ClampByte(ivec4 color) {
    return uvec4(clamp(color, 0, 255));
}

ivec4 BlueContract(int a, int r, int g, int b) {
    return ivec4(a, (r + b) >> 1, (g + b) >> 1, b);
}

void ComputeEndpoints(out uvec4 ep1, out uvec4 ep2, uint color_endpoint_mode, uint color_values[32],
                      inout uint colvals_index) {
#define READ_UINT_VALUES(N)                                                                        \
    uvec4 V[2];                                                                                    \
    for (uint i = 0; i < N; i++) {                                                                 \
        V[i >> 2][i & 3] = color_values[++colvals_index];                      \
    }
#define READ_INT_VALUES(N)                                                                         \
    ivec4 V[2];                                                                                    \
    for (uint i = 0; i < N; i++) {                                                                 \
        V[i >> 2][i & 3] = int(color_values[++colvals_index]);                      \
    }

    switch (color_endpoint_mode) {
    case 0: {
        READ_UINT_VALUES(2)
        ep1 = uvec4(0xFF, V[0].x, V[0].x, V[0].x);
        ep2 = uvec4(0xFF, V[0].y, V[0].y, V[0].y);
        break;
    }
    case 1: {
        READ_UINT_VALUES(2)
        const uint L0 = (V[0].x >> 2) | (V[0].y & 0xC0);
        const uint L1 = min(L0 + (V[0].y & 0x3F), 0xFFU);
        ep1 = uvec4(0xFF, L0, L0, L0);
        ep2 = uvec4(0xFF, L1, L1, L1);
        break;
    }
    case 4: {
        READ_UINT_VALUES(4)
        ep1 = uvec4(V[0].z, V[0].x, V[0].x, V[0].x);
        ep2 = uvec4(V[0].w, V[0].y, V[0].y, V[0].y);
        break;
    }
    case 5: {
        READ_INT_VALUES(4)
        V[0].yx = BitTransferSigned(V[0].y, V[0].x);
        V[0].wz = BitTransferSigned(V[0].w, V[0].z);
        ep1 = ClampByte(ivec4(V[0].z, V[0].x, V[0].x, V[0].x));
        ep2 = ClampByte(ivec4(V[0].z + V[0].w, V[0].x + V[0].y, V[0].x + V[0].y, V[0].x + V[0].y));
        break;
    }
    case 6: {
        READ_UINT_VALUES(4)
        ep1 = uvec4(0xFF, (V[0].x * V[0].w) >> 8, (V[0].y * V[0].w) >> 8, (V[0].z * V[0].w) >> 8);
        ep2 = uvec4(0xFF, V[0].x, V[0].y, V[0].z);
        break;
    }
    case 8: {
        READ_UINT_VALUES(6)
        if ((V[0].y + V[0].w + V[1].y) >= (V[0].x + V[0].z + V[1].x)) {
            ep1 = uvec4(0xFF, V[0].x, V[0].z, V[1].x);
            ep2 = uvec4(0xFF, V[0].y, V[0].w, V[1].y);
        } else {
            ep1 = uvec4(BlueContract(0xFF, int(V[0].y), int(V[0].w), int(V[1].y)));
            ep2 = uvec4(BlueContract(0xFF, int(V[0].x), int(V[0].z), int(V[1].x)));
        }
        break;
    }
    case 9: {
        READ_INT_VALUES(6)
        V[0].yx = BitTransferSigned(V[0].y, V[0].x);
        V[0].wz = BitTransferSigned(V[0].w, V[0].z);
        V[1].yx = BitTransferSigned(V[1].y, V[1].x);
        if ((V[0].y + V[0].w + V[1].y) >= 0) {
            ep1 = ClampByte(ivec4(0xFF, V[0].x, V[0].z, V[1].x));
            ep2 = ClampByte(ivec4(0xFF, V[0].x + V[0].y, V[0].z + V[0].w, V[1].x + V[1].y));
        } else {
            ep1 = ClampByte(BlueContract(0xFF, V[0].x + V[0].y, V[0].z + V[0].w, V[1].x + V[1].y));
            ep2 = ClampByte(BlueContract(0xFF, V[0].x, V[0].z, V[1].x));
        }
        break;
    }
    case 10: {
        READ_UINT_VALUES(6)
        ep1 = uvec4(V[1].x, (V[0].x * V[0].w) >> 8, (V[0].y * V[0].w) >> 8, (V[0].z * V[0].w) >> 8);
        ep2 = uvec4(V[1].y, V[0].x, V[0].y, V[0].z);
        break;
    }
    case 12: {
        READ_UINT_VALUES(8)
        if ((V[0].y + V[0].w + V[1].y) >= (V[0].x + V[0].z + V[1].x)) {
            ep1 = uvec4(V[1].z, V[0].x, V[0].z, V[1].x);
            ep2 = uvec4(V[1].w, V[0].y, V[0].w, V[1].y);
        } else {
            ep1 = uvec4(BlueContract(int(V[1].w), int(V[0].y), int(V[0].w), int(V[1].y)));
            ep2 = uvec4(BlueContract(int(V[1].z), int(V[0].x), int(V[0].z), int(V[1].x)));
        }
        break;
    }
    case 13: {
        READ_INT_VALUES(8)
        V[0].yx = BitTransferSigned(V[0].y, V[0].x);
        V[0].wz = BitTransferSigned(V[0].w, V[0].z);
        V[1].yx = BitTransferSigned(V[1].y, V[1].x);
        V[1].wz = BitTransferSigned(V[1].w, V[1].z);
        if ((V[0].y + V[0].w + V[1].y) >= 0) {
            ep1 = ClampByte(ivec4(V[1].z, V[0].x, V[0].z, V[1].x));
            ep2 = ClampByte(ivec4(V[1].w + V[1].z, V[0].x + V[0].y, V[0].z + V[0].w, V[1].x + V[1].y));
        } else {
            ep1 = ClampByte(BlueContract(V[1].z + V[1].w, V[0].x + V[0].y, V[0].z + V[0].w, V[1].x + V[1].y));
            ep2 = ClampByte(BlueContract(V[1].z, V[0].x, V[0].z, V[1].x));
        }
        break;
    }
    default: {
        // HDR mode, or more likely a bug computing the color_endpoint_mode
        ep1 = uvec4(0xFF, 0xFF, 0, 0);
        ep2 = uvec4(0xFF, 0xFF, 0, 0);
        break;
    }
    }
#undef READ_UINT_VALUES
#undef READ_INT_VALUES
}

uint UnquantizeTexelWeight(EncodingData val) {
    uint encoding = Encoding(val), bitlen = NumBits(val), bitval = BitValue(val);
    if (encoding == JUST_BITS) {
        return (bitlen >= 1 && bitlen <= 5)
            ? uint(floor(0.5f + float(bitval) * 64.0f / float((1 << bitlen) - 1)))
            : FastReplicateTo6(bitval, bitlen);
    } else if (encoding == TRIT || encoding == QUINT) {
        uint B = 0, C = 0, D = 0;
        uint b_mask = (0x3100 >> (bitlen << 2)) & 0xf;
        uint b = (bitval >> 1) & b_mask;
        D = QuintTritValue(val);
        if (encoding == TRIT) {
            switch (bitlen) {
            case 0: return D << 5; //0,32,64
            case 1: C = 50; break;
            case 2: C = 23; B = (b << 6) | (b << 2) | b; break;
            case 3: C = 11; B = (b << 5) | b; break;
            }
        } else if (encoding == QUINT) {
            switch (bitlen) {
            case 0: return D << 4; //0, 16, 32, 48, 64
            case 1: C = 28; break;
            case 2: C = 13; B = (b << 6) | (b << 1); break;
            }
        }
        uint A = ReplicateBitTo7(bitval & 1);
        uint res = (A & 0x20) | (((D * C + B) ^ A) >> 2);
        return res + (res > 32 ? 1 : 0);
    }
    return 0;
}

void UnquantizeTexelWeights(uvec2 size, bool is_dual_plane) {
    const uint num_planes = is_dual_plane ? 2 : 1;
    const uint area = size.x * size.y;
    const uint loop_count = min(result_index, area * num_planes);
    for (uint i = 0; i < loop_count; ++i) {
        result_vector[i] = UnquantizeTexelWeight(EncodingData(result_vector[i]));
    }
}

uint GetUnquantizedTexelWeight(uint offset_base, uint plane, bool is_dual_plane) {
    const uint offset = is_dual_plane ? (offset_base << 1) + plane : offset_base;
    return result_vector[offset];
}

uvec4 GetUnquantizedWeightVector(uvec2 pos, uvec2 size, uint plane_index, bool is_dual_plane) {
    const uint area = size.x * size.y;
    const uvec2 D = uvec2((block_dims * 0.5f + 1024.0f) / (block_dims - 1.0f));
    const uvec2 c = D * pos;
    const uvec2 g = (c * (size - 1) + 32) >> 6;
    const uvec2 j = g >> 4;
    const uvec2 f = g & 0xF;
    const uint w11 = (f.x * f.y + 8) >> 4;
    const uint w10 = f.y - w11;
    const uint w01 = f.x - w11;
    const uint w00 = 16 - f.x - f.y + w11;
    const uvec4 w = uvec4(w00, w01, w10, w11);
    const uint v0 = j.y * size.x + j.x;
    //
    const uvec4 offset_base = uvec4(v0, v0 + 1, v0 + size.x, v0 + size.x + 1);
    const uvec4 cmp_mask = uvec4(0) - uvec4(lessThan(offset_base, uvec4(area)));
    uvec4 p0 = uvec4(
        GetUnquantizedTexelWeight(offset_base.x, 0, is_dual_plane) & cmp_mask.x,
        GetUnquantizedTexelWeight(offset_base.y, 0, is_dual_plane) & cmp_mask.y,
        GetUnquantizedTexelWeight(offset_base.z, 0, is_dual_plane) & cmp_mask.z,
        GetUnquantizedTexelWeight(offset_base.w, 0, is_dual_plane) & cmp_mask.w
    );
    uvec4 p1 = uvec4(
        GetUnquantizedTexelWeight(offset_base.x, 1, is_dual_plane) & cmp_mask.x,
        GetUnquantizedTexelWeight(offset_base.y, 1, is_dual_plane) & cmp_mask.y,
        GetUnquantizedTexelWeight(offset_base.z, 1, is_dual_plane) & cmp_mask.z,
        GetUnquantizedTexelWeight(offset_base.w, 1, is_dual_plane) & cmp_mask.w
    );
    const uvec2 final_weight = (uvec2(uint(dot(p0, w)), uint(dot(p1, w))) + 8) >> 4;
    const uvec4 plane_mask = uvec4(0) - (uvec4(equal(uvec4(((plane_index + 1u) & 3u)), uvec4(0, 1, 2, 3))) & uvec4(0 - uint(is_dual_plane)));
    return (final_weight.yyyy & plane_mask) | (final_weight.xxxx & ~plane_mask);
}

void FillError(ivec3 coord) {
    for (uint j = 0; j < block_dims.y; j++) {
        for (uint i = 0; i < block_dims.x; i++) {
            imageStore(dest_image, coord + ivec3(i, j, 0), vec4(0.0, 0.0, 0.0, 0.0));
        }
    }
}

void FillVoidExtentLDR(uvec4 local_buff, ivec3 coord) {
    // TODO: If you do extract bits, remember that it may be 11, or OTHER
    SkipBits(52);
    const uint r_u = StreamBits(local_buff, 16);
    const uint g_u = StreamBits(local_buff, 16);
    const uint b_u = StreamBits(local_buff, 16);
    const uint a_u = StreamBits(local_buff, 16);
    const float a = float(a_u) / 65535.0f;
    const float r = float(r_u) / 65535.0f;
    const float g = float(g_u) / 65535.0f;
    const float b = float(b_u) / 65535.0f;
    for (uint j = 0; j < block_dims.y; j++) {
        for (uint i = 0; i < block_dims.x; i++) {
            imageStore(dest_image, coord + ivec3(i, j, 0), vec4(r, g, b, a));
        }
    }
}

bool IsError(uvec4 local_buff, uint mode) {
    if ((mode & 0x1ff) == 0x1fc) {
        if ((mode & 0x200) != 0) {
            // params.void_extent_hdr = true;
            return true;
        }
        if ((mode & 0x400) == 0 || StreamBits(local_buff, 1) == 0) {
            return true;
        }
        return false;
    }
    if ((mode & 0xf) == 0) {
        return true;
    }
    if ((mode & 3) == 0 && (mode & 0x1c0) == 0x1c0) {
        return true;
    }
    return false;
}

int FindLayout(uint mode) {
    // Possible (Relevant), x = dont care, (in hex)
    // Before shift: 02x, 08x, 10x, 00x, 0Ax, 12x, 18x, 1Ax
    // After shift:   01,  04,  08,  00,  05,  09,  0c,  0d
    // Reassemble and remove middle 0x040 (stupid fucking table)
    // 0000 -> 0    0020 -> 1   0040 -> 0   0060 -> 1
    // 0080 -> 2    00a0 -> 3   00c0 -> 2   00e0 -> 3
    // 0100 -> 4    0120 -> 5   0140 -> 4   0160 -> 5
    // 0180 -> 6    01a0 -> 7   01c0 -> 6   01e0 -> 7
    // Key ranges: 01a0 -> 7, 0180 -> 6, 0100 -> 4, 0080 -> 2
    // 8>>2 = 2, 4>>2 = 1 :: () = 0, (4) = 1, (8) = 2, (8,4) = 3
    const uint mask = 0 - uint((mode & 3) != 0);
    const uint sh3_mode = (mode >> 2) & 3;
    const uint sh0_mode = ((mode >> 6) & 6) | ((mode >> 5) & 1);
    const uint fl_const_table = 0
        | ((1) << (2 * 4)) //0080 -> 2, 1 + 5 = 6
        | ((1) << (3 * 4))
        | ((4) << (4 * 4)) //0100 -> 4, 4 + 5 = 9
        | ((4) << (5 * 4))
        | ((2) << (6 * 4)) //0180 -> 6, 2 + 5 = 7
        | ((3) << (7 * 4)) //01a0 -> 7, 3 + 5 = 8
    ;
    const uint if_mode3_t = sh3_mode + uint((mode & 0x10c) == 0x10c);
    const uint if_mode3_f = 5 + ((fl_const_table >> (sh0_mode << 2)) & 7);
    return int((if_mode3_t & mask) | (if_mode3_f & ~mask));
}

uvec2 DecodeBlockSize(uint mode_layout, uint mode) {
    uint A, B;
    switch (mode_layout) {
    case 0:
        A = (mode >> 5) & 0x3;
        B = (mode >> 7) & 0x3;
        return uvec2(B + 4, A + 2);
    case 1:
        A = (mode >> 5) & 0x3;
        B = (mode >> 7) & 0x3;
        return uvec2(B + 8, A + 2);
    case 2:
        A = (mode >> 5) & 0x3;
        B = (mode >> 7) & 0x3;
        return uvec2(A + 2, B + 8);
    case 3:
        A = (mode >> 5) & 0x3;
        B = (mode >> 7) & 0x1;
        return uvec2(A + 2, B + 6);
    case 4:
        A = (mode >> 5) & 0x3;
        B = (mode >> 7) & 0x1;
        return uvec2(B + 2, A + 2);
    case 5:
        A = (mode >> 5) & 0x3;
        return uvec2(12, A + 2);
    case 6:
        A = (mode >> 5) & 0x3;
        return uvec2(A + 2, 12);
    case 7:
        return uvec2(6, 10);
    case 8:
        return uvec2(10, 6);
    case 9:
        A = (mode >> 5) & 0x3;
        B = (mode >> 9) & 0x3;
        return uvec2(A + 6, B + 6);
    default:
        return uvec2(0);
    }
}

uint DecodeMaxWeight(uint mode_layout, uint mode) {
    const uint mode0_or = (mode & 0x3) << 1;
    const uint mode5_or = (mode & 0xc) >> 1;
    const uint cmp_moden = 0 - uint(mode_layout < 5);
    const uint cmp_add6 = 0 - (uint(mode_layout != 9) & (mode >> 9) & 1);
    return (((mode >> 4) & 1)
        | (mode0_or & cmp_moden) | (mode5_or & ~cmp_moden))
        + (6 & cmp_add6) - 1;
}

void DecompressBlock(uvec4 local_buff, ivec3 coord) {
    uint mode = StreamBits(local_buff, 11);
    if (IsError(local_buff, mode)) {
        FillError(coord);
        return;
    }
    if ((mode & 0x1ff) == 0x1fc) {
        // params.void_extent_ldr = true;
        FillVoidExtentLDR(local_buff, coord);
        return;
    }
    const uint num_partitions = StreamBits(local_buff, 2) + 1;
    const uint mode_layout = FindLayout(mode);
    const bool dual_plane = (mode_layout != 9) && ((mode & 0x400) != 0);
    const uvec2 size_params = DecodeBlockSize(mode_layout, mode);
    if (size_params.x > block_dims.x || size_params.y > block_dims.y
    || num_partitions > 4 || (num_partitions == 4 && dual_plane)) {
        FillError(coord);
        return;
    }
    uint partition_index = 1;
    uvec4 color_endpoint_mode = uvec4(0);
    uint base_cem = 0;
    if (num_partitions == 1) {
        color_endpoint_mode.x = StreamBits(local_buff, 4);
        partition_index = 0;
    } else {
        partition_index = StreamBits(local_buff, 10);
        base_cem = StreamBits(local_buff, 6);
    }
    const uint base_mode = base_cem & 3;
    const uint max_weight = DecodeMaxWeight(mode_layout, mode);
    const uint weight_bits = GetPackedBitSize(size_params, dual_plane, max_weight);
    const uint extra_cem_bits = base_mode > 0 ? ((0x85200 >> (num_partitions << 2)) & 0x0f) : 0;
    const uint plane_selector_bits = dual_plane ? 2 : 0;
    uint remaining_bits = 128 - weight_bits - total_bitsread;
    remaining_bits -= extra_cem_bits;
    remaining_bits -= plane_selector_bits;
    if (remaining_bits > 128) {
        // Bad data, more remaining bits than 4 bytes
        // return early
        return;
    }
    // Read color data...
    const uint color_data_bits = remaining_bits;
    for (uint i = 0; remaining_bits > 0 && i < 4; ++i) {
        const int nb = int(min(remaining_bits, 32U));
        color_endpoint_data[i] = StreamBits(local_buff, nb);
        remaining_bits -= nb;
    }

    // color_endpoint_mode assumed to be 0 on invalids/out of "range"
    const uint plane_index = uint(StreamBits(local_buff, plane_selector_bits));
    const uvec4 cem_mask = (uvec4(0, 1, 2, 3) - num_partitions) >> 8;
    if (base_mode > 0) {
        const uint extra_cem = StreamBits(local_buff, extra_cem_bits);
        const uint cem = ((extra_cem << 6) | base_cem) >> 2;
        const uint c0 = cem & ((1 << num_partitions) - 1);
        const uint c1 = (cem >> num_partitions) & ((1 << (num_partitions << 1)) - 1);
        const uvec4 c = (uvec4(c0) >> uvec4(0, 1, 2, 3)) & 1;
        const uvec4 m = (uvec4(c1) >> uvec4(0, 2, 4, 6)) & 3;
        color_endpoint_mode = (((uvec4(base_mode) - (1 - c)) << 2) | m) & cem_mask;
    } else if (num_partitions > 1) {
        color_endpoint_mode = uvec4(base_cem >> 2) & cem_mask;
    }

    uvec4 endpoints0[4];
    uvec4 endpoints1[4];
    {
        // This decode phase should at most push 32 elements into the vector
        result_vector_max_index = 32;
        uint color_values[32];
        uint colvals_index = 0;
        DecodeColorValues(color_endpoint_mode, num_partitions, color_data_bits, color_values);
        for (uint i = 0; i < num_partitions; i++)
            ComputeEndpoints(endpoints0[i], endpoints1[i], color_endpoint_mode[i], color_values, colvals_index);
    }
    color_endpoint_data = local_buff;
    color_endpoint_data = bitfieldReverse(color_endpoint_data).wzyx;
    const uint clear_byte_start = (weight_bits >> 3) + 1;

    const uint byte_insert = ExtractBits(color_endpoint_data, (clear_byte_start - 1) << 3, 8) & uint(((1 << (weight_bits & 7)) - 1));
    const uint vec_index = (clear_byte_start - 1) >> 2;
    color_endpoint_data[vec_index] = bitfieldInsert(color_endpoint_data[vec_index], byte_insert, int((clear_byte_start - 1) & 3) << 3, 8);
    for (uint i = clear_byte_start; i < 16; ++i)
        color_endpoint_data[i >> 2] = bitfieldInsert(color_endpoint_data[i >> 2], 0, int(i & 3) << 3, 8);

    // Re-init vector variables for next decode phase
    result_index = 0;
    color_bitsread = 0;

    // The limit for the Unquantize phase, avoids decoding more data than needed.
    result_vector_max_index = (size_params.x * size_params.y) << uint(dual_plane);
    DecodeIntegerSequence(max_weight, GetNumWeightValues(size_params, dual_plane));
    UnquantizeTexelWeights(size_params, dual_plane);
    for (uint j = 0; j < block_dims.y; j++) {
        for (uint i = 0; i < block_dims.x; i++) {
            const uint local_partition = Select2DPartition(partition_index, uvec2(i, j), num_partitions) & (0 - uint(num_partitions > 1));
            const uvec4 C0 = ReplicateByteTo16(endpoints0[local_partition]);
            const uvec4 C1 = ReplicateByteTo16(endpoints1[local_partition]);
            const uvec4 weight_vec = GetUnquantizedWeightVector(uvec2(i, j), size_params, plane_index, dual_plane);
            const vec4 Cf = vec4((C0 * (uvec4(64) - weight_vec) + C1 * weight_vec + 32) >> 6);
            const vec4 p = (Cf / 65535.0f);
            imageStore(dest_image, coord + ivec3(i, j, 0), p.gbar);
        }
    }
}

uint SwizzleOffset(uvec2 pos) {
    return ((pos.x & 32u) << 3u)
        | ((pos.y & 6u)  << 5u)
        | ((pos.x & 16u) << 1u)
        | ((pos.y & 1u)  << 4u)
        | (pos.x & 15u);
}

void main() {
    uvec3 pos = gl_GlobalInvocationID;
    pos.x <<= BYTES_PER_BLOCK_LOG2;
    const uint swizzle = SwizzleOffset(pos.xy);
    const uint block_y = pos.y >> GOB_SIZE_Y_SHIFT;

    uint offset = 0;
    offset += pos.z * layer_stride;
    offset += (block_y >> block_height) * block_size;
    offset += (block_y & block_height_mask) << GOB_SIZE_SHIFT;
    offset += (pos.x >> GOB_SIZE_X_SHIFT) << x_shift;
    offset += swizzle;

    const ivec3 coord = ivec3(gl_GlobalInvocationID * uvec3(block_dims, 1));
    if (any(greaterThanEqual(coord, imageSize(dest_image)))) {
        return;
    }
    DecompressBlock(astc_data[offset >> 4], coord);
}
